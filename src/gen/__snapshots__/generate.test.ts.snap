// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Test sample AST specifications should generate proper output for dogfood.yaml using json 1`] = `
Object {
  "bases": Map {},
  "externs": Set {
    "Field",
  },
  "leaves": Map {
    "BuiltinType" => Object {
      "bases": Array [],
      "fields": Map {
        "types" => Object {
          "struct": "set",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "BuiltinType",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "FieldType",
        "subtypes": Array [],
      },
      "tag": "builtintype",
    },
    "EnumType" => Object {
      "bases": Array [],
      "fields": Map {
        "tags" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "EnumType",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "FieldType",
        "subtypes": Array [],
      },
      "tag": "enumtype",
    },
    "NodeType" => Object {
      "bases": Array [],
      "fields": Map {
        "types" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "NodeType",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "FieldType",
        "subtypes": Array [],
      },
      "tag": "nodetype",
    },
    "ASTUnionType" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "subtypes" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "ASTUnionType",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "ASTTree",
        "subtypes": Array [],
      },
      "tag": "astuniontype",
    },
    "ASTLeafType" => Object {
      "bases": Array [],
      "fields": Map {
        "tag" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "rootUnion" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "ASTUnionType",
            ],
          },
        },
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "bases" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "fields" => Object {
          "struct": "map",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Field",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "ASTLeafType",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "ASTTree",
        "subtypes": Array [],
      },
      "tag": "astleaftype",
    },
  },
  "names": Set {
    "FieldType",
    "BuiltinType",
    "EnumType",
    "NodeType",
    "ASTTree",
    "ASTUnionType",
    "ASTLeafType",
    "Field",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "map",
    "optional": "json",
    "tagName": "kind",
  },
  "unions": Map {
    "FieldType" => Object {
      "kind": "astuniontype",
      "name": "FieldType",
      "subtypes": Array [
        "BuiltinType",
        "EnumType",
        "NodeType",
      ],
    },
    "ASTTree" => Object {
      "kind": "astuniontype",
      "name": "ASTTree",
      "subtypes": Array [
        "ASTUnionType",
        "ASTLeafType",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for dogfood.yaml using json 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the leaf type BuiltinType.
 **/
export interface BuiltinType {
  kind: \\"builtintype\\";
  types: Set<string>;
}
export class BuiltinType {
  /**
   * A predicate function that take an instance of type FieldType and determines if it is an instance of BuiltinType
   **/
  static is = (x: FieldType): x is BuiltinType => {
    return x.kind === \\"builtintype\\";
  };
  /**
   * Given an instance of BuiltinType, determine all children that are instances of FieldType
   **/
  static children = (x: BuiltinType) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of BuiltinType
   **/
  static tag = \\"builtintype\\";
}
/**
 * This function can be invoked to create a new instance of BuiltinType
 **/
export function builtinType(types: Set<string>): BuiltinType {
  return { kind: \\"builtintype\\", types };
}

/**
 * This code implements the types and functions associated with
 * the leaf type EnumType.
 **/
export interface EnumType {
  kind: \\"enumtype\\";
  tags: string[];
}
export class EnumType {
  /**
   * A predicate function that take an instance of type FieldType and determines if it is an instance of EnumType
   **/
  static is = (x: FieldType): x is EnumType => {
    return x.kind === \\"enumtype\\";
  };
  /**
   * Given an instance of EnumType, determine all children that are instances of FieldType
   **/
  static children = (x: EnumType) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of EnumType
   **/
  static tag = \\"enumtype\\";
}
/**
 * This function can be invoked to create a new instance of EnumType
 **/
export function enumType(tags: string[]): EnumType {
  return { kind: \\"enumtype\\", tags };
}

/**
 * This code implements the types and functions associated with
 * the leaf type NodeType.
 **/
export interface NodeType {
  kind: \\"nodetype\\";
  types: string[];
}
export class NodeType {
  /**
   * A predicate function that take an instance of type FieldType and determines if it is an instance of NodeType
   **/
  static is = (x: FieldType): x is NodeType => {
    return x.kind === \\"nodetype\\";
  };
  /**
   * Given an instance of NodeType, determine all children that are instances of FieldType
   **/
  static children = (x: NodeType) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of NodeType
   **/
  static tag = \\"nodetype\\";
}
/**
 * This function can be invoked to create a new instance of NodeType
 **/
export function nodeType(types: string[]): NodeType {
  return { kind: \\"nodetype\\", types };
}

/**
 * This code implements the types and functions associated with
 * the leaf type ASTUnionType.
 **/
export interface ASTUnionType {
  kind: \\"astuniontype\\";
  name: string;
  subtypes: string[];
}
export class ASTUnionType {
  /**
   * A predicate function that take an instance of type ASTTree and determines if it is an instance of ASTUnionType
   **/
  static is = (x: ASTTree): x is ASTUnionType => {
    return x.kind === \\"astuniontype\\";
  };
  /**
   * Given an instance of ASTUnionType, determine all children that are instances of ASTTree
   **/
  static children = (x: ASTUnionType) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of ASTUnionType
   **/
  static tag = \\"astuniontype\\";
}
/**
 * This function can be invoked to create a new instance of ASTUnionType
 **/
export function aSTUnionType(name: string, subtypes: string[]): ASTUnionType {
  return { kind: \\"astuniontype\\", name, subtypes };
}

/**
 * This code implements the types and functions associated with
 * the leaf type ASTLeafType.
 **/
export interface ASTLeafType {
  kind: \\"astleaftype\\";
  tag: string;
  rootUnion: ASTUnionType;
  name: string;
  bases: string[];
  fields: Map<string, Field>;
}
export class ASTLeafType {
  /**
   * A predicate function that take an instance of type ASTTree and determines if it is an instance of ASTLeafType
   **/
  static is = (x: ASTTree): x is ASTLeafType => {
    return x.kind === \\"astleaftype\\";
  };
  /**
   * Given an instance of ASTLeafType, determine all children that are instances of ASTTree
   **/
  static children = (x: ASTLeafType) => {
    return [x.rootUnion, ...Object.entries(x.fields).map((x) => x[1])] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of ASTLeafType
   **/
  static tag = \\"astleaftype\\";
}
/**
 * This function can be invoked to create a new instance of ASTLeafType
 **/
export function aSTLeafType(
  tag: string,
  rootUnion: ASTUnionType,
  name: string,
  bases: string[],
  fields: Map<string, Field>
): ASTLeafType {
  return { kind: \\"astleaftype\\", tag, rootUnion, name, bases, fields };
}

/**
 * This code implements the types and functions associated with
 * the union type FieldType.
 **/
export type FieldType = BuiltinType | EnumType | NodeType;
export namespace FieldType {
  /**
   * Given an instance of type FieldType, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: FieldType,
    f: {
      BuiltinType: (n: BuiltinType) => R;
      EnumType: (n: EnumType) => R;
      NodeType: (n: NodeType) => R;
    }
  ) => {
    switch (n.kind) {
      case \\"builtintype\\":
        return f.BuiltinType(n);
      case \\"enumtype\\":
        return f.EnumType(n);
      case \\"nodetype\\":
        return f.NodeType(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of FieldType has unexpected value for kind: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type FieldType, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: FieldType,
    f: Partial<{
      BuiltinType: (n: BuiltinType) => R;
      EnumType: (n: EnumType) => R;
      NodeType: (n: NodeType) => R;
    }>,
    orElse: R
  ) => {
    if (n.kind === \\"builtintype\\" && f.BuiltinType) return f.BuiltinType(n);
    if (n.kind === \\"enumtype\\" && f.EnumType) return f.EnumType(n);
    if (n.kind === \\"nodetype\\" && f.NodeType) return f.NodeType(n);
    return orElse;
  };
  /**
   * Given an instance of type FieldType, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: FieldType,
    f: {
      BuiltinType: (n: BuiltinType) => void;
      EnumType: (n: EnumType) => void;
      NodeType: (n: NodeType) => void;
    }
  ): void => {
    switch (n.kind) {
      case \\"builtintype\\":
        return f.BuiltinType(n);
      case \\"enumtype\\":
        return f.EnumType(n);
      case \\"nodetype\\":
        return f.NodeType(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of FieldType has unexpected value for kind: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type FieldType, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: FieldType,
    f: Partial<{
      BuiltinType: (n: BuiltinType) => void;
      EnumType: (n: EnumType) => void;
      NodeType: (n: NodeType) => void;
    }>,
    orElse?: (n: FieldType) => void
  ) => {
    if (n.kind === \\"builtintype\\" && f.BuiltinType) return f.BuiltinType(n);
    if (n.kind === \\"enumtype\\" && f.EnumType) return f.EnumType(n);
    if (n.kind === \\"nodetype\\" && f.NodeType) return f.NodeType(n);
    if (orElse) return orElse(n);
  };
}

/**
 * This code implements the types and functions associated with
 * the union type ASTTree.
 **/
export type ASTTree = ASTUnionType | ASTLeafType;
export namespace ASTTree {
  /**
   * Given an instance of type ASTTree, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: ASTTree,
    f: {
      ASTUnionType: (n: ASTUnionType) => R;
      ASTLeafType: (n: ASTLeafType) => R;
    }
  ) => {
    switch (n.kind) {
      case \\"astuniontype\\":
        return f.ASTUnionType(n);
      case \\"astleaftype\\":
        return f.ASTLeafType(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of ASTTree has unexpected value for kind: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type ASTTree, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: ASTTree,
    f: Partial<{
      ASTUnionType: (n: ASTUnionType) => R;
      ASTLeafType: (n: ASTLeafType) => R;
    }>,
    orElse: R
  ) => {
    if (n.kind === \\"astuniontype\\" && f.ASTUnionType) return f.ASTUnionType(n);
    if (n.kind === \\"astleaftype\\" && f.ASTLeafType) return f.ASTLeafType(n);
    return orElse;
  };
  /**
   * Given an instance of type ASTTree, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: ASTTree,
    f: {
      ASTUnionType: (n: ASTUnionType) => void;
      ASTLeafType: (n: ASTLeafType) => void;
    }
  ): void => {
    switch (n.kind) {
      case \\"astuniontype\\":
        return f.ASTUnionType(n);
      case \\"astleaftype\\":
        return f.ASTLeafType(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of ASTTree has unexpected value for kind: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type ASTTree, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: ASTTree,
    f: Partial<{
      ASTUnionType: (n: ASTUnionType) => void;
      ASTLeafType: (n: ASTLeafType) => void;
    }>,
    orElse?: (n: ASTTree) => void
  ) => {
    if (n.kind === \\"astuniontype\\" && f.ASTUnionType) return f.ASTUnionType(n);
    if (n.kind === \\"astleaftype\\" && f.ASTLeafType) return f.ASTLeafType(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for dogfood.yaml using purify 1`] = `
Object {
  "bases": Map {},
  "externs": Set {
    "Field",
  },
  "leaves": Map {
    "BuiltinType" => Object {
      "bases": Array [],
      "fields": Map {
        "types" => Object {
          "struct": "set",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "BuiltinType",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "FieldType",
        "subtypes": Array [],
      },
      "tag": "builtintype",
    },
    "EnumType" => Object {
      "bases": Array [],
      "fields": Map {
        "tags" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "EnumType",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "FieldType",
        "subtypes": Array [],
      },
      "tag": "enumtype",
    },
    "NodeType" => Object {
      "bases": Array [],
      "fields": Map {
        "types" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "NodeType",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "FieldType",
        "subtypes": Array [],
      },
      "tag": "nodetype",
    },
    "ASTUnionType" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "subtypes" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "ASTUnionType",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "ASTTree",
        "subtypes": Array [],
      },
      "tag": "astuniontype",
    },
    "ASTLeafType" => Object {
      "bases": Array [],
      "fields": Map {
        "tag" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "rootUnion" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "ASTUnionType",
            ],
          },
        },
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "bases" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "fields" => Object {
          "struct": "map",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Field",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "ASTLeafType",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "ASTTree",
        "subtypes": Array [],
      },
      "tag": "astleaftype",
    },
  },
  "names": Set {
    "FieldType",
    "BuiltinType",
    "EnumType",
    "NodeType",
    "ASTTree",
    "ASTUnionType",
    "ASTLeafType",
    "Field",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "map",
    "optional": "purify",
    "tagName": "kind",
  },
  "unions": Map {
    "FieldType" => Object {
      "kind": "astuniontype",
      "name": "FieldType",
      "subtypes": Array [
        "BuiltinType",
        "EnumType",
        "NodeType",
      ],
    },
    "ASTTree" => Object {
      "kind": "astuniontype",
      "name": "ASTTree",
      "subtypes": Array [
        "ASTUnionType",
        "ASTLeafType",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for dogfood.yaml using purify 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the leaf type BuiltinType.
 **/
export interface BuiltinType {
  kind: \\"builtintype\\";
  types: Set<string>;
}
export class BuiltinType {
  /**
   * A predicate function that take an instance of type FieldType and determines if it is an instance of BuiltinType
   **/
  static is = (x: FieldType): x is BuiltinType => {
    return x.kind === \\"builtintype\\";
  };
  /**
   * Given an instance of BuiltinType, determine all children that are instances of FieldType
   **/
  static children = (x: BuiltinType) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of BuiltinType
   **/
  static tag = \\"builtintype\\";
}
/**
 * This function can be invoked to create a new instance of BuiltinType
 **/
export function builtinType(types: Set<string>): BuiltinType {
  return { kind: \\"builtintype\\", types };
}

/**
 * This code implements the types and functions associated with
 * the leaf type EnumType.
 **/
export interface EnumType {
  kind: \\"enumtype\\";
  tags: string[];
}
export class EnumType {
  /**
   * A predicate function that take an instance of type FieldType and determines if it is an instance of EnumType
   **/
  static is = (x: FieldType): x is EnumType => {
    return x.kind === \\"enumtype\\";
  };
  /**
   * Given an instance of EnumType, determine all children that are instances of FieldType
   **/
  static children = (x: EnumType) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of EnumType
   **/
  static tag = \\"enumtype\\";
}
/**
 * This function can be invoked to create a new instance of EnumType
 **/
export function enumType(tags: string[]): EnumType {
  return { kind: \\"enumtype\\", tags };
}

/**
 * This code implements the types and functions associated with
 * the leaf type NodeType.
 **/
export interface NodeType {
  kind: \\"nodetype\\";
  types: string[];
}
export class NodeType {
  /**
   * A predicate function that take an instance of type FieldType and determines if it is an instance of NodeType
   **/
  static is = (x: FieldType): x is NodeType => {
    return x.kind === \\"nodetype\\";
  };
  /**
   * Given an instance of NodeType, determine all children that are instances of FieldType
   **/
  static children = (x: NodeType) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of NodeType
   **/
  static tag = \\"nodetype\\";
}
/**
 * This function can be invoked to create a new instance of NodeType
 **/
export function nodeType(types: string[]): NodeType {
  return { kind: \\"nodetype\\", types };
}

/**
 * This code implements the types and functions associated with
 * the leaf type ASTUnionType.
 **/
export interface ASTUnionType {
  kind: \\"astuniontype\\";
  name: string;
  subtypes: string[];
}
export class ASTUnionType {
  /**
   * A predicate function that take an instance of type ASTTree and determines if it is an instance of ASTUnionType
   **/
  static is = (x: ASTTree): x is ASTUnionType => {
    return x.kind === \\"astuniontype\\";
  };
  /**
   * Given an instance of ASTUnionType, determine all children that are instances of ASTTree
   **/
  static children = (x: ASTUnionType) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of ASTUnionType
   **/
  static tag = \\"astuniontype\\";
}
/**
 * This function can be invoked to create a new instance of ASTUnionType
 **/
export function aSTUnionType(name: string, subtypes: string[]): ASTUnionType {
  return { kind: \\"astuniontype\\", name, subtypes };
}

/**
 * This code implements the types and functions associated with
 * the leaf type ASTLeafType.
 **/
export interface ASTLeafType {
  kind: \\"astleaftype\\";
  tag: string;
  rootUnion: ASTUnionType;
  name: string;
  bases: string[];
  fields: Map<string, Field>;
}
export class ASTLeafType {
  /**
   * A predicate function that take an instance of type ASTTree and determines if it is an instance of ASTLeafType
   **/
  static is = (x: ASTTree): x is ASTLeafType => {
    return x.kind === \\"astleaftype\\";
  };
  /**
   * Given an instance of ASTLeafType, determine all children that are instances of ASTTree
   **/
  static children = (x: ASTLeafType) => {
    return [x.rootUnion, ...Object.entries(x.fields).map((x) => x[1])] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of ASTLeafType
   **/
  static tag = \\"astleaftype\\";
}
/**
 * This function can be invoked to create a new instance of ASTLeafType
 **/
export function aSTLeafType(
  tag: string,
  rootUnion: ASTUnionType,
  name: string,
  bases: string[],
  fields: Map<string, Field>
): ASTLeafType {
  return { kind: \\"astleaftype\\", tag, rootUnion, name, bases, fields };
}

/**
 * This code implements the types and functions associated with
 * the union type FieldType.
 **/
export type FieldType = BuiltinType | EnumType | NodeType;
export namespace FieldType {
  /**
   * Given an instance of type FieldType, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: FieldType,
    f: {
      BuiltinType: (n: BuiltinType) => R;
      EnumType: (n: EnumType) => R;
      NodeType: (n: NodeType) => R;
    }
  ) => {
    switch (n.kind) {
      case \\"builtintype\\":
        return f.BuiltinType(n);
      case \\"enumtype\\":
        return f.EnumType(n);
      case \\"nodetype\\":
        return f.NodeType(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of FieldType has unexpected value for kind: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type FieldType, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: FieldType,
    f: Partial<{
      BuiltinType: (n: BuiltinType) => R;
      EnumType: (n: EnumType) => R;
      NodeType: (n: NodeType) => R;
    }>,
    orElse: R
  ) => {
    if (n.kind === \\"builtintype\\" && f.BuiltinType) return f.BuiltinType(n);
    if (n.kind === \\"enumtype\\" && f.EnumType) return f.EnumType(n);
    if (n.kind === \\"nodetype\\" && f.NodeType) return f.NodeType(n);
    return orElse;
  };
  /**
   * Given an instance of type FieldType, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: FieldType,
    f: {
      BuiltinType: (n: BuiltinType) => void;
      EnumType: (n: EnumType) => void;
      NodeType: (n: NodeType) => void;
    }
  ): void => {
    switch (n.kind) {
      case \\"builtintype\\":
        return f.BuiltinType(n);
      case \\"enumtype\\":
        return f.EnumType(n);
      case \\"nodetype\\":
        return f.NodeType(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of FieldType has unexpected value for kind: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type FieldType, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: FieldType,
    f: Partial<{
      BuiltinType: (n: BuiltinType) => void;
      EnumType: (n: EnumType) => void;
      NodeType: (n: NodeType) => void;
    }>,
    orElse?: (n: FieldType) => void
  ) => {
    if (n.kind === \\"builtintype\\" && f.BuiltinType) return f.BuiltinType(n);
    if (n.kind === \\"enumtype\\" && f.EnumType) return f.EnumType(n);
    if (n.kind === \\"nodetype\\" && f.NodeType) return f.NodeType(n);
    if (orElse) return orElse(n);
  };
}

/**
 * This code implements the types and functions associated with
 * the union type ASTTree.
 **/
export type ASTTree = ASTUnionType | ASTLeafType;
export namespace ASTTree {
  /**
   * Given an instance of type ASTTree, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: ASTTree,
    f: {
      ASTUnionType: (n: ASTUnionType) => R;
      ASTLeafType: (n: ASTLeafType) => R;
    }
  ) => {
    switch (n.kind) {
      case \\"astuniontype\\":
        return f.ASTUnionType(n);
      case \\"astleaftype\\":
        return f.ASTLeafType(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of ASTTree has unexpected value for kind: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type ASTTree, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: ASTTree,
    f: Partial<{
      ASTUnionType: (n: ASTUnionType) => R;
      ASTLeafType: (n: ASTLeafType) => R;
    }>,
    orElse: R
  ) => {
    if (n.kind === \\"astuniontype\\" && f.ASTUnionType) return f.ASTUnionType(n);
    if (n.kind === \\"astleaftype\\" && f.ASTLeafType) return f.ASTLeafType(n);
    return orElse;
  };
  /**
   * Given an instance of type ASTTree, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: ASTTree,
    f: {
      ASTUnionType: (n: ASTUnionType) => void;
      ASTLeafType: (n: ASTLeafType) => void;
    }
  ): void => {
    switch (n.kind) {
      case \\"astuniontype\\":
        return f.ASTUnionType(n);
      case \\"astleaftype\\":
        return f.ASTLeafType(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of ASTTree has unexpected value for kind: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type ASTTree, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: ASTTree,
    f: Partial<{
      ASTUnionType: (n: ASTUnionType) => void;
      ASTLeafType: (n: ASTLeafType) => void;
    }>,
    orElse?: (n: ASTTree) => void
  ) => {
    if (n.kind === \\"astuniontype\\" && f.ASTUnionType) return f.ASTUnionType(n);
    if (n.kind === \\"astleaftype\\" && f.ASTLeafType) return f.ASTLeafType(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using json 1`] = `
Object {
  "bases": Map {
    "BinaryOp" => Object {
      "bases": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
      },
      "name": "BinaryOp",
    },
  },
  "externs": Set {},
  "leaves": Map {
    "Literal" => Object {
      "bases": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Literal",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "literal",
    },
    "ArithmeticOp" => Object {
      "bases": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              "+",
              "-",
              "*",
              "/",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "ArithmeticOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "arithmeticop",
    },
    "UnaryOp" => Object {
      "bases": Array [],
      "fields": Map {
        "expr" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              "()",
              "+",
              "-",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "UnaryOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "unaryop",
    },
    "RelOp" => Object {
      "bases": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              "+",
              "-",
              "*",
              "/",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "RelOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "relop",
    },
  },
  "names": Set {
    "Expr",
    "Literal",
    "ArithmeticOp",
    "UnaryOp",
    "RelOp",
    "BinaryOp",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "json",
    "tagName": "tag",
  },
  "unions": Map {
    "Expr" => Object {
      "kind": "astuniontype",
      "name": "Expr",
      "subtypes": Array [
        "Literal",
        "ArithmeticOp",
        "UnaryOp",
        "RelOp",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using json 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the base type BinaryOp.
 **/
export interface BinaryOp {
  left: Expr;
  right: Expr;
}

/**
 * This code implements the types and functions associated with
 * the leaf type Literal.
 **/
export interface Literal {
  tag: \\"literal\\";
  value: number;
}
export class Literal {
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of Literal
   **/
  static is = (x: Expr): x is Literal => {
    return x.tag === \\"literal\\";
  };
  /**
   * Given an instance of Literal, determine all children that are instances of Expr
   **/
  static children = (x: Literal) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Literal
   **/
  static tag = \\"literal\\";
}
/**
 * This function can be invoked to create a new instance of Literal
 **/
export function literal(value: number): Literal {
  return { tag: \\"literal\\", value };
}

/**
 * This code implements the types and functions associated with
 * the leaf type ArithmeticOp.
 **/
export interface ArithmeticOp extends BinaryOp {
  tag: \\"arithmeticop\\";
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\";
}
export class ArithmeticOp {
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of ArithmeticOp
   **/
  static is = (x: Expr): x is ArithmeticOp => {
    return x.tag === \\"arithmeticop\\";
  };
  /**
   * Given an instance of ArithmeticOp, determine all children that are instances of Expr
   **/
  static children = (x: ArithmeticOp) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of ArithmeticOp
   **/
  static tag = \\"arithmeticop\\";
}
/**
 * This function can be invoked to create a new instance of ArithmeticOp
 **/
export function arithmeticOp(
  left: Expr,
  right: Expr,
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\"
): ArithmeticOp {
  return { tag: \\"arithmeticop\\", left, right, op };
}

/**
 * This code implements the types and functions associated with
 * the leaf type UnaryOp.
 **/
export interface UnaryOp {
  tag: \\"unaryop\\";
  expr: Expr;
  op: \\"()\\" | \\"+\\" | \\"-\\";
}
export class UnaryOp {
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of UnaryOp
   **/
  static is = (x: Expr): x is UnaryOp => {
    return x.tag === \\"unaryop\\";
  };
  /**
   * Given an instance of UnaryOp, determine all children that are instances of Expr
   **/
  static children = (x: UnaryOp) => {
    return [x.expr] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of UnaryOp
   **/
  static tag = \\"unaryop\\";
}
/**
 * This function can be invoked to create a new instance of UnaryOp
 **/
export function unaryOp(expr: Expr, op: \\"()\\" | \\"+\\" | \\"-\\"): UnaryOp {
  return { tag: \\"unaryop\\", expr, op };
}

/**
 * This code implements the types and functions associated with
 * the leaf type RelOp.
 **/
export interface RelOp extends BinaryOp {
  tag: \\"relop\\";
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\";
}
export class RelOp {
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of RelOp
   **/
  static is = (x: Expr): x is RelOp => {
    return x.tag === \\"relop\\";
  };
  /**
   * Given an instance of RelOp, determine all children that are instances of Expr
   **/
  static children = (x: RelOp) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of RelOp
   **/
  static tag = \\"relop\\";
}
/**
 * This function can be invoked to create a new instance of RelOp
 **/
export function relOp(
  left: Expr,
  right: Expr,
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\"
): RelOp {
  return { tag: \\"relop\\", left, right, op };
}

/**
 * This code implements the types and functions associated with
 * the union type Expr.
 **/
export type Expr = Literal | ArithmeticOp | UnaryOp | RelOp;
export namespace Expr {
  /**
   * Given an instance of type Expr, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Expr,
    f: {
      Literal: (n: Literal) => R;
      ArithmeticOp: (n: ArithmeticOp) => R;
      UnaryOp: (n: UnaryOp) => R;
      RelOp: (n: RelOp) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"literal\\":
        return f.Literal(n);
      case \\"arithmeticop\\":
        return f.ArithmeticOp(n);
      case \\"unaryop\\":
        return f.UnaryOp(n);
      case \\"relop\\":
        return f.RelOp(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Expr has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Expr, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Expr,
    f: Partial<{
      Literal: (n: Literal) => R;
      ArithmeticOp: (n: ArithmeticOp) => R;
      UnaryOp: (n: UnaryOp) => R;
      RelOp: (n: RelOp) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"literal\\" && f.Literal) return f.Literal(n);
    if (n.tag === \\"arithmeticop\\" && f.ArithmeticOp) return f.ArithmeticOp(n);
    if (n.tag === \\"unaryop\\" && f.UnaryOp) return f.UnaryOp(n);
    if (n.tag === \\"relop\\" && f.RelOp) return f.RelOp(n);
    return orElse;
  };
  /**
   * Given an instance of type Expr, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Expr,
    f: {
      Literal: (n: Literal) => void;
      ArithmeticOp: (n: ArithmeticOp) => void;
      UnaryOp: (n: UnaryOp) => void;
      RelOp: (n: RelOp) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"literal\\":
        return f.Literal(n);
      case \\"arithmeticop\\":
        return f.ArithmeticOp(n);
      case \\"unaryop\\":
        return f.UnaryOp(n);
      case \\"relop\\":
        return f.RelOp(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Expr has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Expr, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Expr,
    f: Partial<{
      Literal: (n: Literal) => void;
      ArithmeticOp: (n: ArithmeticOp) => void;
      UnaryOp: (n: UnaryOp) => void;
      RelOp: (n: RelOp) => void;
    }>,
    orElse?: (n: Expr) => void
  ) => {
    if (n.tag === \\"literal\\" && f.Literal) return f.Literal(n);
    if (n.tag === \\"arithmeticop\\" && f.ArithmeticOp) return f.ArithmeticOp(n);
    if (n.tag === \\"unaryop\\" && f.UnaryOp) return f.UnaryOp(n);
    if (n.tag === \\"relop\\" && f.RelOp) return f.RelOp(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using purify 1`] = `
Object {
  "bases": Map {
    "BinaryOp" => Object {
      "bases": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
      },
      "name": "BinaryOp",
    },
  },
  "externs": Set {},
  "leaves": Map {
    "Literal" => Object {
      "bases": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Literal",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "literal",
    },
    "ArithmeticOp" => Object {
      "bases": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              "+",
              "-",
              "*",
              "/",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "ArithmeticOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "arithmeticop",
    },
    "UnaryOp" => Object {
      "bases": Array [],
      "fields": Map {
        "expr" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              "()",
              "+",
              "-",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "UnaryOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "unaryop",
    },
    "RelOp" => Object {
      "bases": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              "+",
              "-",
              "*",
              "/",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "RelOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "relop",
    },
  },
  "names": Set {
    "Expr",
    "Literal",
    "ArithmeticOp",
    "UnaryOp",
    "RelOp",
    "BinaryOp",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "purify",
    "tagName": "tag",
  },
  "unions": Map {
    "Expr" => Object {
      "kind": "astuniontype",
      "name": "Expr",
      "subtypes": Array [
        "Literal",
        "ArithmeticOp",
        "UnaryOp",
        "RelOp",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using purify 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the base type BinaryOp.
 **/
export interface BinaryOp {
  left: Expr;
  right: Expr;
}

/**
 * This code implements the types and functions associated with
 * the leaf type Literal.
 **/
export interface Literal {
  tag: \\"literal\\";
  value: number;
}
export class Literal {
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of Literal
   **/
  static is = (x: Expr): x is Literal => {
    return x.tag === \\"literal\\";
  };
  /**
   * Given an instance of Literal, determine all children that are instances of Expr
   **/
  static children = (x: Literal) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Literal
   **/
  static tag = \\"literal\\";
}
/**
 * This function can be invoked to create a new instance of Literal
 **/
export function literal(value: number): Literal {
  return { tag: \\"literal\\", value };
}

/**
 * This code implements the types and functions associated with
 * the leaf type ArithmeticOp.
 **/
export interface ArithmeticOp extends BinaryOp {
  tag: \\"arithmeticop\\";
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\";
}
export class ArithmeticOp {
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of ArithmeticOp
   **/
  static is = (x: Expr): x is ArithmeticOp => {
    return x.tag === \\"arithmeticop\\";
  };
  /**
   * Given an instance of ArithmeticOp, determine all children that are instances of Expr
   **/
  static children = (x: ArithmeticOp) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of ArithmeticOp
   **/
  static tag = \\"arithmeticop\\";
}
/**
 * This function can be invoked to create a new instance of ArithmeticOp
 **/
export function arithmeticOp(
  left: Expr,
  right: Expr,
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\"
): ArithmeticOp {
  return { tag: \\"arithmeticop\\", left, right, op };
}

/**
 * This code implements the types and functions associated with
 * the leaf type UnaryOp.
 **/
export interface UnaryOp {
  tag: \\"unaryop\\";
  expr: Expr;
  op: \\"()\\" | \\"+\\" | \\"-\\";
}
export class UnaryOp {
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of UnaryOp
   **/
  static is = (x: Expr): x is UnaryOp => {
    return x.tag === \\"unaryop\\";
  };
  /**
   * Given an instance of UnaryOp, determine all children that are instances of Expr
   **/
  static children = (x: UnaryOp) => {
    return [x.expr] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of UnaryOp
   **/
  static tag = \\"unaryop\\";
}
/**
 * This function can be invoked to create a new instance of UnaryOp
 **/
export function unaryOp(expr: Expr, op: \\"()\\" | \\"+\\" | \\"-\\"): UnaryOp {
  return { tag: \\"unaryop\\", expr, op };
}

/**
 * This code implements the types and functions associated with
 * the leaf type RelOp.
 **/
export interface RelOp extends BinaryOp {
  tag: \\"relop\\";
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\";
}
export class RelOp {
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of RelOp
   **/
  static is = (x: Expr): x is RelOp => {
    return x.tag === \\"relop\\";
  };
  /**
   * Given an instance of RelOp, determine all children that are instances of Expr
   **/
  static children = (x: RelOp) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of RelOp
   **/
  static tag = \\"relop\\";
}
/**
 * This function can be invoked to create a new instance of RelOp
 **/
export function relOp(
  left: Expr,
  right: Expr,
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\"
): RelOp {
  return { tag: \\"relop\\", left, right, op };
}

/**
 * This code implements the types and functions associated with
 * the union type Expr.
 **/
export type Expr = Literal | ArithmeticOp | UnaryOp | RelOp;
export namespace Expr {
  /**
   * Given an instance of type Expr, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Expr,
    f: {
      Literal: (n: Literal) => R;
      ArithmeticOp: (n: ArithmeticOp) => R;
      UnaryOp: (n: UnaryOp) => R;
      RelOp: (n: RelOp) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"literal\\":
        return f.Literal(n);
      case \\"arithmeticop\\":
        return f.ArithmeticOp(n);
      case \\"unaryop\\":
        return f.UnaryOp(n);
      case \\"relop\\":
        return f.RelOp(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Expr has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Expr, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Expr,
    f: Partial<{
      Literal: (n: Literal) => R;
      ArithmeticOp: (n: ArithmeticOp) => R;
      UnaryOp: (n: UnaryOp) => R;
      RelOp: (n: RelOp) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"literal\\" && f.Literal) return f.Literal(n);
    if (n.tag === \\"arithmeticop\\" && f.ArithmeticOp) return f.ArithmeticOp(n);
    if (n.tag === \\"unaryop\\" && f.UnaryOp) return f.UnaryOp(n);
    if (n.tag === \\"relop\\" && f.RelOp) return f.RelOp(n);
    return orElse;
  };
  /**
   * Given an instance of type Expr, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Expr,
    f: {
      Literal: (n: Literal) => void;
      ArithmeticOp: (n: ArithmeticOp) => void;
      UnaryOp: (n: UnaryOp) => void;
      RelOp: (n: RelOp) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"literal\\":
        return f.Literal(n);
      case \\"arithmeticop\\":
        return f.ArithmeticOp(n);
      case \\"unaryop\\":
        return f.UnaryOp(n);
      case \\"relop\\":
        return f.RelOp(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Expr has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Expr, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Expr,
    f: Partial<{
      Literal: (n: Literal) => void;
      ArithmeticOp: (n: ArithmeticOp) => void;
      UnaryOp: (n: UnaryOp) => void;
      RelOp: (n: RelOp) => void;
    }>,
    orElse?: (n: Expr) => void
  ) => {
    if (n.tag === \\"literal\\" && f.Literal) return f.Literal(n);
    if (n.tag === \\"arithmeticop\\" && f.ArithmeticOp) return f.ArithmeticOp(n);
    if (n.tag === \\"unaryop\\" && f.UnaryOp) return f.UnaryOp(n);
    if (n.tag === \\"relop\\" && f.RelOp) return f.RelOp(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using json 1`] = `
Object {
  "bases": Map {},
  "externs": Set {},
  "leaves": Map {
    "FunctionDef" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "args" => Object {
          "struct": "array",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Argument",
            ],
          },
        },
        "body" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Body",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "FunctionDef",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "functiondef",
    },
    "Declaration" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "init" => Object {
          "struct": "optional",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Declaration",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "declaration",
    },
    "Argument" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Argument",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "argument",
    },
    "Body" => Object {
      "bases": Array [],
      "fields": Map {
        "statement" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Statement",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "Body",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "body",
    },
    "AssignmentStatement" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "init" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "AssignmentStatement",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "assignmentstatement",
    },
    "DeclarationStatement" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "DeclarationStatement",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "declarationstatement",
    },
  },
  "names": Set {
    "Node",
    "FunctionDef",
    "Declaration",
    "Argument",
    "Body",
    "Statement",
    "AssignmentStatement",
    "DeclarationStatement",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "json",
    "tagName": "tag",
  },
  "unions": Map {
    "Statement" => Object {
      "kind": "astuniontype",
      "name": "Statement",
      "subtypes": Array [
        "AssignmentStatement",
        "DeclarationStatement",
      ],
    },
    "Node" => Object {
      "kind": "astuniontype",
      "name": "Node",
      "subtypes": Array [
        "FunctionDef",
        "Declaration",
        "Argument",
        "Body",
        "Statement",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using json 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the leaf type FunctionDef.
 **/
export interface FunctionDef {
  tag: \\"functiondef\\";
  name: string;
  args: Argument[];
  body: Body;
}
export class FunctionDef {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of FunctionDef
   **/
  static is = (x: Node): x is FunctionDef => {
    return x.tag === \\"functiondef\\";
  };
  /**
   * Given an instance of FunctionDef, determine all children that are instances of Node
   **/
  static children = (x: FunctionDef) => {
    return [x.body, ...x.args] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of FunctionDef
   **/
  static tag = \\"functiondef\\";
}
/**
 * This function can be invoked to create a new instance of FunctionDef
 **/
export function functionDef(
  name: string,
  args: Argument[],
  body: Body
): FunctionDef {
  return { tag: \\"functiondef\\", name, args, body };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Declaration.
 **/
export interface Declaration {
  tag: \\"declaration\\";
  name: string;
  type: string;
  init?: number;
}
export class Declaration {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Declaration
   **/
  static is = (x: Node): x is Declaration => {
    return x.tag === \\"declaration\\";
  };
  /**
   * Given an instance of Declaration, determine all children that are instances of Node
   **/
  static children = (x: Declaration) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Declaration
   **/
  static tag = \\"declaration\\";
}
/**
 * This function can be invoked to create a new instance of Declaration
 **/
export function declaration(
  name: string,
  type: string,
  init: number | undefined
): Declaration {
  return { tag: \\"declaration\\", name, type, init };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Argument.
 **/
export interface Argument {
  tag: \\"argument\\";
  name: string;
  type: string;
}
export class Argument {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Argument
   **/
  static is = (x: Node): x is Argument => {
    return x.tag === \\"argument\\";
  };
  /**
   * Given an instance of Argument, determine all children that are instances of Node
   **/
  static children = (x: Argument) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Argument
   **/
  static tag = \\"argument\\";
}
/**
 * This function can be invoked to create a new instance of Argument
 **/
export function argument(name: string, type: string): Argument {
  return { tag: \\"argument\\", name, type };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Body.
 **/
export interface Body {
  tag: \\"body\\";
  statement: Statement;
}
export class Body {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Body
   **/
  static is = (x: Node): x is Body => {
    return x.tag === \\"body\\";
  };
  /**
   * Given an instance of Body, determine all children that are instances of Node
   **/
  static children = (x: Body) => {
    return [x.statement] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Body
   **/
  static tag = \\"body\\";
}
/**
 * This function can be invoked to create a new instance of Body
 **/
export function body(statement: Statement): Body {
  return { tag: \\"body\\", statement };
}

/**
 * This code implements the types and functions associated with
 * the leaf type AssignmentStatement.
 **/
export interface AssignmentStatement {
  tag: \\"assignmentstatement\\";
  name: string;
  init: number;
}
export class AssignmentStatement {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of AssignmentStatement
   **/
  static is = (x: Node): x is AssignmentStatement => {
    return x.tag === \\"assignmentstatement\\";
  };
  /**
   * Given an instance of AssignmentStatement, determine all children that are instances of Node
   **/
  static children = (x: AssignmentStatement) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of AssignmentStatement
   **/
  static tag = \\"assignmentstatement\\";
}
/**
 * This function can be invoked to create a new instance of AssignmentStatement
 **/
export function assignmentStatement(
  name: string,
  init: number
): AssignmentStatement {
  return { tag: \\"assignmentstatement\\", name, init };
}

/**
 * This code implements the types and functions associated with
 * the leaf type DeclarationStatement.
 **/
export interface DeclarationStatement {
  tag: \\"declarationstatement\\";
  name: string;
}
export class DeclarationStatement {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of DeclarationStatement
   **/
  static is = (x: Node): x is DeclarationStatement => {
    return x.tag === \\"declarationstatement\\";
  };
  /**
   * Given an instance of DeclarationStatement, determine all children that are instances of Node
   **/
  static children = (x: DeclarationStatement) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of DeclarationStatement
   **/
  static tag = \\"declarationstatement\\";
}
/**
 * This function can be invoked to create a new instance of DeclarationStatement
 **/
export function declarationStatement(name: string): DeclarationStatement {
  return { tag: \\"declarationstatement\\", name };
}

/**
 * This code implements the types and functions associated with
 * the union type Statement.
 **/
export type Statement = AssignmentStatement | DeclarationStatement;
export namespace Statement {
  /**
   * Given an instance of type Statement, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Statement,
    f: {
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Statement has unexpected value for tag: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Statement, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Statement,
    f: Partial<{
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    return orElse;
  };
  /**
   * Given an instance of type Statement, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Statement,
    f: {
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Statement has unexpected value for tag: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Statement, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Statement,
    f: Partial<{
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }>,
    orElse?: (n: Statement) => void
  ) => {
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    if (orElse) return orElse(n);
  };
}

/**
 * This code implements the types and functions associated with
 * the union type Node.
 **/
export type Node = FunctionDef | Declaration | Argument | Body | Statement;
export namespace Node {
  /**
   * Given an instance of type Node, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Node,
    f: {
      FunctionDef: (n: FunctionDef) => R;
      Declaration: (n: Declaration) => R;
      Argument: (n: Argument) => R;
      Body: (n: Body) => R;
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"functiondef\\":
        return f.FunctionDef(n);
      case \\"declaration\\":
        return f.Declaration(n);
      case \\"argument\\":
        return f.Argument(n);
      case \\"body\\":
        return f.Body(n);
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Node has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Node, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Node,
    f: Partial<{
      FunctionDef: (n: FunctionDef) => R;
      Declaration: (n: Declaration) => R;
      Argument: (n: Argument) => R;
      Body: (n: Body) => R;
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"functiondef\\" && f.FunctionDef) return f.FunctionDef(n);
    if (n.tag === \\"declaration\\" && f.Declaration) return f.Declaration(n);
    if (n.tag === \\"argument\\" && f.Argument) return f.Argument(n);
    if (n.tag === \\"body\\" && f.Body) return f.Body(n);
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    return orElse;
  };
  /**
   * Given an instance of type Node, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Node,
    f: {
      FunctionDef: (n: FunctionDef) => void;
      Declaration: (n: Declaration) => void;
      Argument: (n: Argument) => void;
      Body: (n: Body) => void;
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"functiondef\\":
        return f.FunctionDef(n);
      case \\"declaration\\":
        return f.Declaration(n);
      case \\"argument\\":
        return f.Argument(n);
      case \\"body\\":
        return f.Body(n);
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Node has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Node, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Node,
    f: Partial<{
      FunctionDef: (n: FunctionDef) => void;
      Declaration: (n: Declaration) => void;
      Argument: (n: Argument) => void;
      Body: (n: Body) => void;
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }>,
    orElse?: (n: Node) => void
  ) => {
    if (n.tag === \\"functiondef\\" && f.FunctionDef) return f.FunctionDef(n);
    if (n.tag === \\"declaration\\" && f.Declaration) return f.Declaration(n);
    if (n.tag === \\"argument\\" && f.Argument) return f.Argument(n);
    if (n.tag === \\"body\\" && f.Body) return f.Body(n);
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using purify 1`] = `
Object {
  "bases": Map {},
  "externs": Set {},
  "leaves": Map {
    "FunctionDef" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "args" => Object {
          "struct": "array",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Argument",
            ],
          },
        },
        "body" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Body",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "FunctionDef",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "functiondef",
    },
    "Declaration" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "init" => Object {
          "struct": "optional",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Declaration",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "declaration",
    },
    "Argument" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Argument",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "argument",
    },
    "Body" => Object {
      "bases": Array [],
      "fields": Map {
        "statement" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Statement",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "Body",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "body",
    },
    "AssignmentStatement" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "init" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "AssignmentStatement",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "assignmentstatement",
    },
    "DeclarationStatement" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "DeclarationStatement",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "declarationstatement",
    },
  },
  "names": Set {
    "Node",
    "FunctionDef",
    "Declaration",
    "Argument",
    "Body",
    "Statement",
    "AssignmentStatement",
    "DeclarationStatement",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "purify",
    "tagName": "tag",
  },
  "unions": Map {
    "Statement" => Object {
      "kind": "astuniontype",
      "name": "Statement",
      "subtypes": Array [
        "AssignmentStatement",
        "DeclarationStatement",
      ],
    },
    "Node" => Object {
      "kind": "astuniontype",
      "name": "Node",
      "subtypes": Array [
        "FunctionDef",
        "Declaration",
        "Argument",
        "Body",
        "Statement",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using purify 2`] = `
"import { Maybe } from \\"purify-ts/Maybe\\";
/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the leaf type FunctionDef.
 **/
export interface FunctionDef {
  tag: \\"functiondef\\";
  name: string;
  args: Argument[];
  body: Body;
}
export class FunctionDef {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of FunctionDef
   **/
  static is = (x: Node): x is FunctionDef => {
    return x.tag === \\"functiondef\\";
  };
  /**
   * Given an instance of FunctionDef, determine all children that are instances of Node
   **/
  static children = (x: FunctionDef) => {
    return [x.body, ...x.args] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of FunctionDef
   **/
  static tag = \\"functiondef\\";
}
/**
 * This function can be invoked to create a new instance of FunctionDef
 **/
export function functionDef(
  name: string,
  args: Argument[],
  body: Body
): FunctionDef {
  return { tag: \\"functiondef\\", name, args, body };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Declaration.
 **/
export interface Declaration {
  tag: \\"declaration\\";
  name: string;
  type: string;
  init: Maybe<number>;
}
export class Declaration {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Declaration
   **/
  static is = (x: Node): x is Declaration => {
    return x.tag === \\"declaration\\";
  };
  /**
   * Given an instance of Declaration, determine all children that are instances of Node
   **/
  static children = (x: Declaration) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Declaration
   **/
  static tag = \\"declaration\\";
}
/**
 * This function can be invoked to create a new instance of Declaration
 **/
export function declaration(
  name: string,
  type: string,
  init: Maybe<number>
): Declaration {
  return { tag: \\"declaration\\", name, type, init };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Argument.
 **/
export interface Argument {
  tag: \\"argument\\";
  name: string;
  type: string;
}
export class Argument {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Argument
   **/
  static is = (x: Node): x is Argument => {
    return x.tag === \\"argument\\";
  };
  /**
   * Given an instance of Argument, determine all children that are instances of Node
   **/
  static children = (x: Argument) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Argument
   **/
  static tag = \\"argument\\";
}
/**
 * This function can be invoked to create a new instance of Argument
 **/
export function argument(name: string, type: string): Argument {
  return { tag: \\"argument\\", name, type };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Body.
 **/
export interface Body {
  tag: \\"body\\";
  statement: Statement;
}
export class Body {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Body
   **/
  static is = (x: Node): x is Body => {
    return x.tag === \\"body\\";
  };
  /**
   * Given an instance of Body, determine all children that are instances of Node
   **/
  static children = (x: Body) => {
    return [x.statement] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Body
   **/
  static tag = \\"body\\";
}
/**
 * This function can be invoked to create a new instance of Body
 **/
export function body(statement: Statement): Body {
  return { tag: \\"body\\", statement };
}

/**
 * This code implements the types and functions associated with
 * the leaf type AssignmentStatement.
 **/
export interface AssignmentStatement {
  tag: \\"assignmentstatement\\";
  name: string;
  init: number;
}
export class AssignmentStatement {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of AssignmentStatement
   **/
  static is = (x: Node): x is AssignmentStatement => {
    return x.tag === \\"assignmentstatement\\";
  };
  /**
   * Given an instance of AssignmentStatement, determine all children that are instances of Node
   **/
  static children = (x: AssignmentStatement) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of AssignmentStatement
   **/
  static tag = \\"assignmentstatement\\";
}
/**
 * This function can be invoked to create a new instance of AssignmentStatement
 **/
export function assignmentStatement(
  name: string,
  init: number
): AssignmentStatement {
  return { tag: \\"assignmentstatement\\", name, init };
}

/**
 * This code implements the types and functions associated with
 * the leaf type DeclarationStatement.
 **/
export interface DeclarationStatement {
  tag: \\"declarationstatement\\";
  name: string;
}
export class DeclarationStatement {
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of DeclarationStatement
   **/
  static is = (x: Node): x is DeclarationStatement => {
    return x.tag === \\"declarationstatement\\";
  };
  /**
   * Given an instance of DeclarationStatement, determine all children that are instances of Node
   **/
  static children = (x: DeclarationStatement) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of DeclarationStatement
   **/
  static tag = \\"declarationstatement\\";
}
/**
 * This function can be invoked to create a new instance of DeclarationStatement
 **/
export function declarationStatement(name: string): DeclarationStatement {
  return { tag: \\"declarationstatement\\", name };
}

/**
 * This code implements the types and functions associated with
 * the union type Statement.
 **/
export type Statement = AssignmentStatement | DeclarationStatement;
export namespace Statement {
  /**
   * Given an instance of type Statement, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Statement,
    f: {
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Statement has unexpected value for tag: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Statement, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Statement,
    f: Partial<{
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    return orElse;
  };
  /**
   * Given an instance of type Statement, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Statement,
    f: {
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Statement has unexpected value for tag: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Statement, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Statement,
    f: Partial<{
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }>,
    orElse?: (n: Statement) => void
  ) => {
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    if (orElse) return orElse(n);
  };
}

/**
 * This code implements the types and functions associated with
 * the union type Node.
 **/
export type Node = FunctionDef | Declaration | Argument | Body | Statement;
export namespace Node {
  /**
   * Given an instance of type Node, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Node,
    f: {
      FunctionDef: (n: FunctionDef) => R;
      Declaration: (n: Declaration) => R;
      Argument: (n: Argument) => R;
      Body: (n: Body) => R;
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"functiondef\\":
        return f.FunctionDef(n);
      case \\"declaration\\":
        return f.Declaration(n);
      case \\"argument\\":
        return f.Argument(n);
      case \\"body\\":
        return f.Body(n);
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Node has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Node, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Node,
    f: Partial<{
      FunctionDef: (n: FunctionDef) => R;
      Declaration: (n: Declaration) => R;
      Argument: (n: Argument) => R;
      Body: (n: Body) => R;
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"functiondef\\" && f.FunctionDef) return f.FunctionDef(n);
    if (n.tag === \\"declaration\\" && f.Declaration) return f.Declaration(n);
    if (n.tag === \\"argument\\" && f.Argument) return f.Argument(n);
    if (n.tag === \\"body\\" && f.Body) return f.Body(n);
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    return orElse;
  };
  /**
   * Given an instance of type Node, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Node,
    f: {
      FunctionDef: (n: FunctionDef) => void;
      Declaration: (n: Declaration) => void;
      Argument: (n: Argument) => void;
      Body: (n: Body) => void;
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"functiondef\\":
        return f.FunctionDef(n);
      case \\"declaration\\":
        return f.Declaration(n);
      case \\"argument\\":
        return f.Argument(n);
      case \\"body\\":
        return f.Body(n);
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Node has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Node, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Node,
    f: Partial<{
      FunctionDef: (n: FunctionDef) => void;
      Declaration: (n: Declaration) => void;
      Argument: (n: Argument) => void;
      Body: (n: Body) => void;
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }>,
    orElse?: (n: Node) => void
  ) => {
    if (n.tag === \\"functiondef\\" && f.FunctionDef) return f.FunctionDef(n);
    if (n.tag === \\"declaration\\" && f.Declaration) return f.Declaration(n);
    if (n.tag === \\"argument\\" && f.Argument) return f.Argument(n);
    if (n.tag === \\"body\\" && f.Body) return f.Body(n);
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using json 1`] = `
Object {
  "bases": Map {},
  "externs": Set {},
  "leaves": Map {
    "Fork" => Object {
      "bases": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Tree",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Tree",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "Fork",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Tree",
        "subtypes": Array [],
      },
      "tag": "fork",
    },
    "Leaf" => Object {
      "bases": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Leaf",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Tree",
        "subtypes": Array [],
      },
      "tag": "leaf",
    },
  },
  "names": Set {
    "Tree",
    "Fork",
    "Leaf",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "json",
    "tagName": "tag",
  },
  "unions": Map {
    "Tree" => Object {
      "kind": "astuniontype",
      "name": "Tree",
      "subtypes": Array [
        "Fork",
        "Leaf",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using json 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the leaf type Fork.
 **/
export interface Fork {
  tag: \\"fork\\";
  left: Tree;
  right: Tree;
}
export class Fork {
  /**
   * A predicate function that take an instance of type Tree and determines if it is an instance of Fork
   **/
  static is = (x: Tree): x is Fork => {
    return x.tag === \\"fork\\";
  };
  /**
   * Given an instance of Fork, determine all children that are instances of Tree
   **/
  static children = (x: Fork) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Fork
   **/
  static tag = \\"fork\\";
}
/**
 * This function can be invoked to create a new instance of Fork
 **/
export function fork(left: Tree, right: Tree): Fork {
  return { tag: \\"fork\\", left, right };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Leaf.
 **/
export interface Leaf {
  tag: \\"leaf\\";
  value: number;
}
export class Leaf {
  /**
   * A predicate function that take an instance of type Tree and determines if it is an instance of Leaf
   **/
  static is = (x: Tree): x is Leaf => {
    return x.tag === \\"leaf\\";
  };
  /**
   * Given an instance of Leaf, determine all children that are instances of Tree
   **/
  static children = (x: Leaf) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Leaf
   **/
  static tag = \\"leaf\\";
}
/**
 * This function can be invoked to create a new instance of Leaf
 **/
export function leaf(value: number): Leaf {
  return { tag: \\"leaf\\", value };
}

/**
 * This code implements the types and functions associated with
 * the union type Tree.
 **/
export type Tree = Fork | Leaf;
export namespace Tree {
  /**
   * Given an instance of type Tree, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Tree,
    f: {
      Fork: (n: Fork) => R;
      Leaf: (n: Leaf) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"fork\\":
        return f.Fork(n);
      case \\"leaf\\":
        return f.Leaf(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Tree has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Tree, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Tree,
    f: Partial<{
      Fork: (n: Fork) => R;
      Leaf: (n: Leaf) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"fork\\" && f.Fork) return f.Fork(n);
    if (n.tag === \\"leaf\\" && f.Leaf) return f.Leaf(n);
    return orElse;
  };
  /**
   * Given an instance of type Tree, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Tree,
    f: {
      Fork: (n: Fork) => void;
      Leaf: (n: Leaf) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"fork\\":
        return f.Fork(n);
      case \\"leaf\\":
        return f.Leaf(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Tree has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Tree, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Tree,
    f: Partial<{
      Fork: (n: Fork) => void;
      Leaf: (n: Leaf) => void;
    }>,
    orElse?: (n: Tree) => void
  ) => {
    if (n.tag === \\"fork\\" && f.Fork) return f.Fork(n);
    if (n.tag === \\"leaf\\" && f.Leaf) return f.Leaf(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using purify 1`] = `
Object {
  "bases": Map {},
  "externs": Set {},
  "leaves": Map {
    "Fork" => Object {
      "bases": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Tree",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Tree",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "Fork",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Tree",
        "subtypes": Array [],
      },
      "tag": "fork",
    },
    "Leaf" => Object {
      "bases": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Leaf",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Tree",
        "subtypes": Array [],
      },
      "tag": "leaf",
    },
  },
  "names": Set {
    "Tree",
    "Fork",
    "Leaf",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "purify",
    "tagName": "tag",
  },
  "unions": Map {
    "Tree" => Object {
      "kind": "astuniontype",
      "name": "Tree",
      "subtypes": Array [
        "Fork",
        "Leaf",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using purify 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the leaf type Fork.
 **/
export interface Fork {
  tag: \\"fork\\";
  left: Tree;
  right: Tree;
}
export class Fork {
  /**
   * A predicate function that take an instance of type Tree and determines if it is an instance of Fork
   **/
  static is = (x: Tree): x is Fork => {
    return x.tag === \\"fork\\";
  };
  /**
   * Given an instance of Fork, determine all children that are instances of Tree
   **/
  static children = (x: Fork) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Fork
   **/
  static tag = \\"fork\\";
}
/**
 * This function can be invoked to create a new instance of Fork
 **/
export function fork(left: Tree, right: Tree): Fork {
  return { tag: \\"fork\\", left, right };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Leaf.
 **/
export interface Leaf {
  tag: \\"leaf\\";
  value: number;
}
export class Leaf {
  /**
   * A predicate function that take an instance of type Tree and determines if it is an instance of Leaf
   **/
  static is = (x: Tree): x is Leaf => {
    return x.tag === \\"leaf\\";
  };
  /**
   * Given an instance of Leaf, determine all children that are instances of Tree
   **/
  static children = (x: Leaf) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Leaf
   **/
  static tag = \\"leaf\\";
}
/**
 * This function can be invoked to create a new instance of Leaf
 **/
export function leaf(value: number): Leaf {
  return { tag: \\"leaf\\", value };
}

/**
 * This code implements the types and functions associated with
 * the union type Tree.
 **/
export type Tree = Fork | Leaf;
export namespace Tree {
  /**
   * Given an instance of type Tree, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Tree,
    f: {
      Fork: (n: Fork) => R;
      Leaf: (n: Leaf) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"fork\\":
        return f.Fork(n);
      case \\"leaf\\":
        return f.Leaf(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Tree has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Tree, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Tree,
    f: Partial<{
      Fork: (n: Fork) => R;
      Leaf: (n: Leaf) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"fork\\" && f.Fork) return f.Fork(n);
    if (n.tag === \\"leaf\\" && f.Leaf) return f.Leaf(n);
    return orElse;
  };
  /**
   * Given an instance of type Tree, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Tree,
    f: {
      Fork: (n: Fork) => void;
      Leaf: (n: Leaf) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"fork\\":
        return f.Fork(n);
      case \\"leaf\\":
        return f.Leaf(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Tree has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Tree, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Tree,
    f: Partial<{
      Fork: (n: Fork) => void;
      Leaf: (n: Leaf) => void;
    }>,
    orElse?: (n: Tree) => void
  ) => {
    if (n.tag === \\"fork\\" && f.Fork) return f.Fork(n);
    if (n.tag === \\"leaf\\" && f.Leaf) return f.Leaf(n);
    if (orElse) return orElse(n);
  };
}
"
`;
