// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Test sample AST specifications should generate proper output for expr.yaml using json 1`] = `
Object {
  "bases": Map {
    "BinaryOp" => Object {
      "bases": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
      },
      "name": "BinaryOp",
    },
  },
  "externs": Set {},
  "leaves": Map {
    "Literal" => Object {
      "bases": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Literal",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "literal",
    },
    "ArithmeticOp" => Object {
      "bases": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              "+",
              "-",
              "*",
              "/",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "ArithmeticOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "arithmeticop",
    },
    "UnaryOp" => Object {
      "bases": Array [],
      "fields": Map {
        "expr" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              "()",
              "+",
              "-",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "UnaryOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "unaryop",
    },
    "RelOp" => Object {
      "bases": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              ">",
              "<",
              ">=",
              "<=",
              "==",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "RelOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "relop",
    },
  },
  "names": Set {
    "BinaryOp",
    "Expr",
    "Literal",
    "ArithmeticOp",
    "UnaryOp",
    "RelOp",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "json",
    "tagName": "tag",
  },
  "unions": Map {
    "Expr" => Object {
      "kind": "astuniontype",
      "name": "Expr",
      "subtypes": Array [
        "Literal",
        "ArithmeticOp",
        "UnaryOp",
        "RelOp",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using json 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the interface type BinaryOp.
 **/
export interface BinaryOp {
  left: Expr;
  right: Expr;
}

/**
 * This code implements the types and functions associated with
 * the leaf type Literal.
 **/
export interface Literal {
  tag: \\"literal\\";
  value: number;
}
export class Literal {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Literal
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Literal => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"value\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"literal\\";
  };
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of Literal
   **/
  static is = (x: Expr): x is Literal => {
    return x.tag === \\"literal\\";
  };
  /**
   * Given an instance of Literal, determine all children that are instances of Expr
   **/
  static children = (x: Literal) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Literal
   **/
  static tag = \\"literal\\";
}
/**
 * This function can be invoked to create a new instance of Literal
 **/
export function literal(value: number): Literal {
  return { tag: \\"literal\\", value };
}

/**
 * This code implements the types and functions associated with
 * the leaf type ArithmeticOp.
 **/
export interface ArithmeticOp extends BinaryOp {
  tag: \\"arithmeticop\\";
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\";
}
export class ArithmeticOp {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of ArithmeticOp
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is ArithmeticOp => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"op\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"arithmeticop\\";
  };
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of ArithmeticOp
   **/
  static is = (x: Expr): x is ArithmeticOp => {
    return x.tag === \\"arithmeticop\\";
  };
  /**
   * Given an instance of ArithmeticOp, determine all children that are instances of Expr
   **/
  static children = (x: ArithmeticOp) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of ArithmeticOp
   **/
  static tag = \\"arithmeticop\\";
}
/**
 * This function can be invoked to create a new instance of ArithmeticOp
 **/
export function arithmeticOp(
  left: Expr,
  right: Expr,
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\"
): ArithmeticOp {
  return { tag: \\"arithmeticop\\", left, right, op };
}

/**
 * This code implements the types and functions associated with
 * the leaf type UnaryOp.
 **/
export interface UnaryOp {
  tag: \\"unaryop\\";
  expr: Expr;
  op: \\"()\\" | \\"+\\" | \\"-\\";
}
export class UnaryOp {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of UnaryOp
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is UnaryOp => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 3) return false;
    if (!keys.includes(\\"expr\\")) return false;
    if (!keys.includes(\\"op\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"unaryop\\";
  };
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of UnaryOp
   **/
  static is = (x: Expr): x is UnaryOp => {
    return x.tag === \\"unaryop\\";
  };
  /**
   * Given an instance of UnaryOp, determine all children that are instances of Expr
   **/
  static children = (x: UnaryOp) => {
    return [x.expr] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of UnaryOp
   **/
  static tag = \\"unaryop\\";
}
/**
 * This function can be invoked to create a new instance of UnaryOp
 **/
export function unaryOp(expr: Expr, op: \\"()\\" | \\"+\\" | \\"-\\"): UnaryOp {
  return { tag: \\"unaryop\\", expr, op };
}

/**
 * This code implements the types and functions associated with
 * the leaf type RelOp.
 **/
export interface RelOp extends BinaryOp {
  tag: \\"relop\\";
  op: \\">\\" | \\"<\\" | \\">=\\" | \\"<=\\" | \\"==\\";
}
export class RelOp {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of RelOp
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is RelOp => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"op\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"relop\\";
  };
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of RelOp
   **/
  static is = (x: Expr): x is RelOp => {
    return x.tag === \\"relop\\";
  };
  /**
   * Given an instance of RelOp, determine all children that are instances of Expr
   **/
  static children = (x: RelOp) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of RelOp
   **/
  static tag = \\"relop\\";
}
/**
 * This function can be invoked to create a new instance of RelOp
 **/
export function relOp(
  left: Expr,
  right: Expr,
  op: \\">\\" | \\"<\\" | \\">=\\" | \\"<=\\" | \\"==\\"
): RelOp {
  return { tag: \\"relop\\", left, right, op };
}

/**
 * This code implements the types and functions associated with
 * the union type Expr.
 **/
export type Expr = Literal | ArithmeticOp | UnaryOp | RelOp;
export namespace Expr {
  /**
   * Given an instance of \`any\` determine it is an instance of any of the leaf types of Expr
   **/
  export const anyIs = (n: any): n is Expr => {
    if (Literal.anyIs(n)) return true;
    if (ArithmeticOp.anyIs(n)) return true;
    if (UnaryOp.anyIs(n)) return true;
    if (RelOp.anyIs(n)) return true;
    return false;
  };
  /**
   * Given an instance of Expr, return a list of all children
   **/
  export const children = (n: Expr): readonly Expr[] =>
    map(n, {
      Literal: (c): readonly Expr[] =>
        Literal.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      ArithmeticOp: (c): readonly Expr[] =>
        ArithmeticOp.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      UnaryOp: (c): readonly Expr[] =>
        UnaryOp.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      RelOp: (c): readonly Expr[] =>
        RelOp.children(c)
          .map((x) => x as any)
          .filter(anyIs),
    });
  /**
   * Given an instance of type Expr, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Expr,
    f: {
      Literal: (n: Literal) => R;
      ArithmeticOp: (n: ArithmeticOp) => R;
      UnaryOp: (n: UnaryOp) => R;
      RelOp: (n: RelOp) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"literal\\":
        return f.Literal(n);
      case \\"arithmeticop\\":
        return f.ArithmeticOp(n);
      case \\"unaryop\\":
        return f.UnaryOp(n);
      case \\"relop\\":
        return f.RelOp(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Expr has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Expr, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Expr,
    f: Partial<{
      Literal: (n: Literal) => R;
      ArithmeticOp: (n: ArithmeticOp) => R;
      UnaryOp: (n: UnaryOp) => R;
      RelOp: (n: RelOp) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"literal\\" && f.Literal) return f.Literal(n);
    if (n.tag === \\"arithmeticop\\" && f.ArithmeticOp) return f.ArithmeticOp(n);
    if (n.tag === \\"unaryop\\" && f.UnaryOp) return f.UnaryOp(n);
    if (n.tag === \\"relop\\" && f.RelOp) return f.RelOp(n);
    return orElse;
  };
  /**
   * Given an instance of type Expr, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Expr,
    f: {
      Literal: (n: Literal) => void;
      ArithmeticOp: (n: ArithmeticOp) => void;
      UnaryOp: (n: UnaryOp) => void;
      RelOp: (n: RelOp) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"literal\\":
        return f.Literal(n);
      case \\"arithmeticop\\":
        return f.ArithmeticOp(n);
      case \\"unaryop\\":
        return f.UnaryOp(n);
      case \\"relop\\":
        return f.RelOp(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Expr has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Expr, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Expr,
    f: Partial<{
      Literal: (n: Literal) => void;
      ArithmeticOp: (n: ArithmeticOp) => void;
      UnaryOp: (n: UnaryOp) => void;
      RelOp: (n: RelOp) => void;
    }>,
    orElse?: (n: Expr) => void
  ) => {
    if (n.tag === \\"literal\\" && f.Literal) return f.Literal(n);
    if (n.tag === \\"arithmeticop\\" && f.ArithmeticOp) return f.ArithmeticOp(n);
    if (n.tag === \\"unaryop\\" && f.UnaryOp) return f.UnaryOp(n);
    if (n.tag === \\"relop\\" && f.RelOp) return f.RelOp(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using purify 1`] = `
Object {
  "bases": Map {
    "BinaryOp" => Object {
      "bases": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
      },
      "name": "BinaryOp",
    },
  },
  "externs": Set {},
  "leaves": Map {
    "Literal" => Object {
      "bases": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Literal",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "literal",
    },
    "ArithmeticOp" => Object {
      "bases": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              "+",
              "-",
              "*",
              "/",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "ArithmeticOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "arithmeticop",
    },
    "UnaryOp" => Object {
      "bases": Array [],
      "fields": Map {
        "expr" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Expr",
            ],
          },
        },
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              "()",
              "+",
              "-",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "UnaryOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "unaryop",
    },
    "RelOp" => Object {
      "bases": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enumtype",
            "tags": Array [
              ">",
              "<",
              ">=",
              "<=",
              "==",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "RelOp",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Expr",
        "subtypes": Array [],
      },
      "tag": "relop",
    },
  },
  "names": Set {
    "BinaryOp",
    "Expr",
    "Literal",
    "ArithmeticOp",
    "UnaryOp",
    "RelOp",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "purify",
    "tagName": "tag",
  },
  "unions": Map {
    "Expr" => Object {
      "kind": "astuniontype",
      "name": "Expr",
      "subtypes": Array [
        "Literal",
        "ArithmeticOp",
        "UnaryOp",
        "RelOp",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using purify 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the interface type BinaryOp.
 **/
export interface BinaryOp {
  left: Expr;
  right: Expr;
}

/**
 * This code implements the types and functions associated with
 * the leaf type Literal.
 **/
export interface Literal {
  tag: \\"literal\\";
  value: number;
}
export class Literal {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Literal
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Literal => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"value\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"literal\\";
  };
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of Literal
   **/
  static is = (x: Expr): x is Literal => {
    return x.tag === \\"literal\\";
  };
  /**
   * Given an instance of Literal, determine all children that are instances of Expr
   **/
  static children = (x: Literal) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Literal
   **/
  static tag = \\"literal\\";
}
/**
 * This function can be invoked to create a new instance of Literal
 **/
export function literal(value: number): Literal {
  return { tag: \\"literal\\", value };
}

/**
 * This code implements the types and functions associated with
 * the leaf type ArithmeticOp.
 **/
export interface ArithmeticOp extends BinaryOp {
  tag: \\"arithmeticop\\";
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\";
}
export class ArithmeticOp {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of ArithmeticOp
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is ArithmeticOp => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"op\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"arithmeticop\\";
  };
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of ArithmeticOp
   **/
  static is = (x: Expr): x is ArithmeticOp => {
    return x.tag === \\"arithmeticop\\";
  };
  /**
   * Given an instance of ArithmeticOp, determine all children that are instances of Expr
   **/
  static children = (x: ArithmeticOp) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of ArithmeticOp
   **/
  static tag = \\"arithmeticop\\";
}
/**
 * This function can be invoked to create a new instance of ArithmeticOp
 **/
export function arithmeticOp(
  left: Expr,
  right: Expr,
  op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\"
): ArithmeticOp {
  return { tag: \\"arithmeticop\\", left, right, op };
}

/**
 * This code implements the types and functions associated with
 * the leaf type UnaryOp.
 **/
export interface UnaryOp {
  tag: \\"unaryop\\";
  expr: Expr;
  op: \\"()\\" | \\"+\\" | \\"-\\";
}
export class UnaryOp {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of UnaryOp
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is UnaryOp => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 3) return false;
    if (!keys.includes(\\"expr\\")) return false;
    if (!keys.includes(\\"op\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"unaryop\\";
  };
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of UnaryOp
   **/
  static is = (x: Expr): x is UnaryOp => {
    return x.tag === \\"unaryop\\";
  };
  /**
   * Given an instance of UnaryOp, determine all children that are instances of Expr
   **/
  static children = (x: UnaryOp) => {
    return [x.expr] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of UnaryOp
   **/
  static tag = \\"unaryop\\";
}
/**
 * This function can be invoked to create a new instance of UnaryOp
 **/
export function unaryOp(expr: Expr, op: \\"()\\" | \\"+\\" | \\"-\\"): UnaryOp {
  return { tag: \\"unaryop\\", expr, op };
}

/**
 * This code implements the types and functions associated with
 * the leaf type RelOp.
 **/
export interface RelOp extends BinaryOp {
  tag: \\"relop\\";
  op: \\">\\" | \\"<\\" | \\">=\\" | \\"<=\\" | \\"==\\";
}
export class RelOp {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of RelOp
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is RelOp => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"op\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"relop\\";
  };
  /**
   * A predicate function that take an instance of type Expr and determines if it is an instance of RelOp
   **/
  static is = (x: Expr): x is RelOp => {
    return x.tag === \\"relop\\";
  };
  /**
   * Given an instance of RelOp, determine all children that are instances of Expr
   **/
  static children = (x: RelOp) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of RelOp
   **/
  static tag = \\"relop\\";
}
/**
 * This function can be invoked to create a new instance of RelOp
 **/
export function relOp(
  left: Expr,
  right: Expr,
  op: \\">\\" | \\"<\\" | \\">=\\" | \\"<=\\" | \\"==\\"
): RelOp {
  return { tag: \\"relop\\", left, right, op };
}

/**
 * This code implements the types and functions associated with
 * the union type Expr.
 **/
export type Expr = Literal | ArithmeticOp | UnaryOp | RelOp;
export namespace Expr {
  /**
   * Given an instance of \`any\` determine it is an instance of any of the leaf types of Expr
   **/
  export const anyIs = (n: any): n is Expr => {
    if (Literal.anyIs(n)) return true;
    if (ArithmeticOp.anyIs(n)) return true;
    if (UnaryOp.anyIs(n)) return true;
    if (RelOp.anyIs(n)) return true;
    return false;
  };
  /**
   * Given an instance of Expr, return a list of all children
   **/
  export const children = (n: Expr): readonly Expr[] =>
    map(n, {
      Literal: (c): readonly Expr[] =>
        Literal.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      ArithmeticOp: (c): readonly Expr[] =>
        ArithmeticOp.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      UnaryOp: (c): readonly Expr[] =>
        UnaryOp.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      RelOp: (c): readonly Expr[] =>
        RelOp.children(c)
          .map((x) => x as any)
          .filter(anyIs),
    });
  /**
   * Given an instance of type Expr, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Expr,
    f: {
      Literal: (n: Literal) => R;
      ArithmeticOp: (n: ArithmeticOp) => R;
      UnaryOp: (n: UnaryOp) => R;
      RelOp: (n: RelOp) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"literal\\":
        return f.Literal(n);
      case \\"arithmeticop\\":
        return f.ArithmeticOp(n);
      case \\"unaryop\\":
        return f.UnaryOp(n);
      case \\"relop\\":
        return f.RelOp(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Expr has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Expr, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Expr,
    f: Partial<{
      Literal: (n: Literal) => R;
      ArithmeticOp: (n: ArithmeticOp) => R;
      UnaryOp: (n: UnaryOp) => R;
      RelOp: (n: RelOp) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"literal\\" && f.Literal) return f.Literal(n);
    if (n.tag === \\"arithmeticop\\" && f.ArithmeticOp) return f.ArithmeticOp(n);
    if (n.tag === \\"unaryop\\" && f.UnaryOp) return f.UnaryOp(n);
    if (n.tag === \\"relop\\" && f.RelOp) return f.RelOp(n);
    return orElse;
  };
  /**
   * Given an instance of type Expr, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Expr,
    f: {
      Literal: (n: Literal) => void;
      ArithmeticOp: (n: ArithmeticOp) => void;
      UnaryOp: (n: UnaryOp) => void;
      RelOp: (n: RelOp) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"literal\\":
        return f.Literal(n);
      case \\"arithmeticop\\":
        return f.ArithmeticOp(n);
      case \\"unaryop\\":
        return f.UnaryOp(n);
      case \\"relop\\":
        return f.RelOp(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Expr has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Expr, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Expr,
    f: Partial<{
      Literal: (n: Literal) => void;
      ArithmeticOp: (n: ArithmeticOp) => void;
      UnaryOp: (n: UnaryOp) => void;
      RelOp: (n: RelOp) => void;
    }>,
    orElse?: (n: Expr) => void
  ) => {
    if (n.tag === \\"literal\\" && f.Literal) return f.Literal(n);
    if (n.tag === \\"arithmeticop\\" && f.ArithmeticOp) return f.ArithmeticOp(n);
    if (n.tag === \\"unaryop\\" && f.UnaryOp) return f.UnaryOp(n);
    if (n.tag === \\"relop\\" && f.RelOp) return f.RelOp(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using json 1`] = `
Object {
  "bases": Map {},
  "externs": Set {},
  "leaves": Map {
    "FunctionDef" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "args" => Object {
          "struct": "array",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Argument",
            ],
          },
        },
        "body" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Body",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "FunctionDef",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "functiondef",
    },
    "Declaration" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "init" => Object {
          "struct": "optional",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Declaration",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "declaration",
    },
    "Argument" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Argument",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "argument",
    },
    "Body" => Object {
      "bases": Array [],
      "fields": Map {
        "statement" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Statement",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "Body",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "body",
    },
    "AssignmentStatement" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "init" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "AssignmentStatement",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "assignmentstatement",
    },
    "DeclarationStatement" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "DeclarationStatement",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "declarationstatement",
    },
  },
  "names": Set {
    "Node",
    "FunctionDef",
    "Declaration",
    "Argument",
    "Body",
    "Statement",
    "AssignmentStatement",
    "DeclarationStatement",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "json",
    "tagName": "tag",
  },
  "unions": Map {
    "Statement" => Object {
      "kind": "astuniontype",
      "name": "Statement",
      "subtypes": Array [
        "AssignmentStatement",
        "DeclarationStatement",
      ],
    },
    "Node" => Object {
      "kind": "astuniontype",
      "name": "Node",
      "subtypes": Array [
        "FunctionDef",
        "Declaration",
        "Argument",
        "Body",
        "Statement",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using json 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the leaf type FunctionDef.
 **/
export interface FunctionDef {
  tag: \\"functiondef\\";
  name: string;
  args: Argument[];
  body: Body;
}
export class FunctionDef {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of FunctionDef
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is FunctionDef => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 4) return false;
    if (!keys.includes(\\"name\\")) return false;
    if (!keys.includes(\\"args\\")) return false;
    if (!keys.includes(\\"body\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"functiondef\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of FunctionDef
   **/
  static is = (x: Node): x is FunctionDef => {
    return x.tag === \\"functiondef\\";
  };
  /**
   * Given an instance of FunctionDef, determine all children that are instances of Node
   **/
  static children = (x: FunctionDef) => {
    return [x.body, ...x.args] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of FunctionDef
   **/
  static tag = \\"functiondef\\";
}
/**
 * This function can be invoked to create a new instance of FunctionDef
 **/
export function functionDef(
  name: string,
  args: Argument[],
  body: Body
): FunctionDef {
  return { tag: \\"functiondef\\", name, args, body };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Declaration.
 **/
export interface Declaration {
  tag: \\"declaration\\";
  name: string;
  type: string;
  init?: number;
}
export class Declaration {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Declaration
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Declaration => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 4) return false;
    if (!keys.includes(\\"name\\")) return false;
    if (!keys.includes(\\"type\\")) return false;
    if (!keys.includes(\\"init\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"declaration\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Declaration
   **/
  static is = (x: Node): x is Declaration => {
    return x.tag === \\"declaration\\";
  };
  /**
   * Given an instance of Declaration, determine all children that are instances of Node
   **/
  static children = (x: Declaration) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Declaration
   **/
  static tag = \\"declaration\\";
}
/**
 * This function can be invoked to create a new instance of Declaration
 **/
export function declaration(
  name: string,
  type: string,
  init: number | undefined
): Declaration {
  return { tag: \\"declaration\\", name, type, init };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Argument.
 **/
export interface Argument {
  tag: \\"argument\\";
  name: string;
  type: string;
}
export class Argument {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Argument
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Argument => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 3) return false;
    if (!keys.includes(\\"name\\")) return false;
    if (!keys.includes(\\"type\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"argument\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Argument
   **/
  static is = (x: Node): x is Argument => {
    return x.tag === \\"argument\\";
  };
  /**
   * Given an instance of Argument, determine all children that are instances of Node
   **/
  static children = (x: Argument) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Argument
   **/
  static tag = \\"argument\\";
}
/**
 * This function can be invoked to create a new instance of Argument
 **/
export function argument(name: string, type: string): Argument {
  return { tag: \\"argument\\", name, type };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Body.
 **/
export interface Body {
  tag: \\"body\\";
  statement: Statement;
}
export class Body {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Body
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Body => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"statement\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"body\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Body
   **/
  static is = (x: Node): x is Body => {
    return x.tag === \\"body\\";
  };
  /**
   * Given an instance of Body, determine all children that are instances of Node
   **/
  static children = (x: Body) => {
    return [x.statement] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Body
   **/
  static tag = \\"body\\";
}
/**
 * This function can be invoked to create a new instance of Body
 **/
export function body(statement: Statement): Body {
  return { tag: \\"body\\", statement };
}

/**
 * This code implements the types and functions associated with
 * the leaf type AssignmentStatement.
 **/
export interface AssignmentStatement {
  tag: \\"assignmentstatement\\";
  name: string;
  init: number;
}
export class AssignmentStatement {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of AssignmentStatement
   **/
  static anyIs = (
    x: any,
    allowExtra: boolean = false
  ): x is AssignmentStatement => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 3) return false;
    if (!keys.includes(\\"name\\")) return false;
    if (!keys.includes(\\"init\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"assignmentstatement\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of AssignmentStatement
   **/
  static is = (x: Node): x is AssignmentStatement => {
    return x.tag === \\"assignmentstatement\\";
  };
  /**
   * Given an instance of AssignmentStatement, determine all children that are instances of Node
   **/
  static children = (x: AssignmentStatement) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of AssignmentStatement
   **/
  static tag = \\"assignmentstatement\\";
}
/**
 * This function can be invoked to create a new instance of AssignmentStatement
 **/
export function assignmentStatement(
  name: string,
  init: number
): AssignmentStatement {
  return { tag: \\"assignmentstatement\\", name, init };
}

/**
 * This code implements the types and functions associated with
 * the leaf type DeclarationStatement.
 **/
export interface DeclarationStatement {
  tag: \\"declarationstatement\\";
  name: string;
}
export class DeclarationStatement {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of DeclarationStatement
   **/
  static anyIs = (
    x: any,
    allowExtra: boolean = false
  ): x is DeclarationStatement => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"name\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"declarationstatement\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of DeclarationStatement
   **/
  static is = (x: Node): x is DeclarationStatement => {
    return x.tag === \\"declarationstatement\\";
  };
  /**
   * Given an instance of DeclarationStatement, determine all children that are instances of Node
   **/
  static children = (x: DeclarationStatement) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of DeclarationStatement
   **/
  static tag = \\"declarationstatement\\";
}
/**
 * This function can be invoked to create a new instance of DeclarationStatement
 **/
export function declarationStatement(name: string): DeclarationStatement {
  return { tag: \\"declarationstatement\\", name };
}

/**
 * This code implements the types and functions associated with
 * the union type Statement.
 **/
export type Statement = AssignmentStatement | DeclarationStatement;
export namespace Statement {
  /**
   * Given an instance of \`any\` determine it is an instance of any of the leaf types of Statement
   **/
  export const anyIs = (n: any): n is Statement => {
    if (AssignmentStatement.anyIs(n)) return true;
    if (DeclarationStatement.anyIs(n)) return true;
    return false;
  };
  /**
   * Given an instance of Statement, return a list of all children
   **/
  export const children = (n: Statement): readonly Statement[] =>
    map(n, {
      AssignmentStatement: (c): readonly Statement[] =>
        AssignmentStatement.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      DeclarationStatement: (c): readonly Statement[] =>
        DeclarationStatement.children(c)
          .map((x) => x as any)
          .filter(anyIs),
    });
  /**
   * Given an instance of type Statement, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Statement,
    f: {
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Statement has unexpected value for tag: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Statement, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Statement,
    f: Partial<{
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    return orElse;
  };
  /**
   * Given an instance of type Statement, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Statement,
    f: {
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Statement has unexpected value for tag: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Statement, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Statement,
    f: Partial<{
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }>,
    orElse?: (n: Statement) => void
  ) => {
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    if (orElse) return orElse(n);
  };
}

/**
 * This code implements the types and functions associated with
 * the union type Node.
 **/
export type Node = FunctionDef | Declaration | Argument | Body | Statement;
export namespace Node {
  /**
   * Given an instance of \`any\` determine it is an instance of any of the leaf types of Node
   **/
  export const anyIs = (n: any): n is Node => {
    if (FunctionDef.anyIs(n)) return true;
    if (Declaration.anyIs(n)) return true;
    if (Argument.anyIs(n)) return true;
    if (Body.anyIs(n)) return true;
    if (AssignmentStatement.anyIs(n)) return true;
    if (DeclarationStatement.anyIs(n)) return true;
    return false;
  };
  /**
   * Given an instance of Node, return a list of all children
   **/
  export const children = (n: Node): readonly Node[] =>
    map(n, {
      FunctionDef: (c): readonly Node[] =>
        FunctionDef.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      Declaration: (c): readonly Node[] =>
        Declaration.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      Argument: (c): readonly Node[] =>
        Argument.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      Body: (c): readonly Node[] =>
        Body.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      AssignmentStatement: (c): readonly Node[] =>
        AssignmentStatement.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      DeclarationStatement: (c): readonly Node[] =>
        DeclarationStatement.children(c)
          .map((x) => x as any)
          .filter(anyIs),
    });
  /**
   * Given an instance of type Node, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Node,
    f: {
      FunctionDef: (n: FunctionDef) => R;
      Declaration: (n: Declaration) => R;
      Argument: (n: Argument) => R;
      Body: (n: Body) => R;
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"functiondef\\":
        return f.FunctionDef(n);
      case \\"declaration\\":
        return f.Declaration(n);
      case \\"argument\\":
        return f.Argument(n);
      case \\"body\\":
        return f.Body(n);
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Node has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Node, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Node,
    f: Partial<{
      FunctionDef: (n: FunctionDef) => R;
      Declaration: (n: Declaration) => R;
      Argument: (n: Argument) => R;
      Body: (n: Body) => R;
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"functiondef\\" && f.FunctionDef) return f.FunctionDef(n);
    if (n.tag === \\"declaration\\" && f.Declaration) return f.Declaration(n);
    if (n.tag === \\"argument\\" && f.Argument) return f.Argument(n);
    if (n.tag === \\"body\\" && f.Body) return f.Body(n);
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    return orElse;
  };
  /**
   * Given an instance of type Node, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Node,
    f: {
      FunctionDef: (n: FunctionDef) => void;
      Declaration: (n: Declaration) => void;
      Argument: (n: Argument) => void;
      Body: (n: Body) => void;
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"functiondef\\":
        return f.FunctionDef(n);
      case \\"declaration\\":
        return f.Declaration(n);
      case \\"argument\\":
        return f.Argument(n);
      case \\"body\\":
        return f.Body(n);
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Node has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Node, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Node,
    f: Partial<{
      FunctionDef: (n: FunctionDef) => void;
      Declaration: (n: Declaration) => void;
      Argument: (n: Argument) => void;
      Body: (n: Body) => void;
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }>,
    orElse?: (n: Node) => void
  ) => {
    if (n.tag === \\"functiondef\\" && f.FunctionDef) return f.FunctionDef(n);
    if (n.tag === \\"declaration\\" && f.Declaration) return f.Declaration(n);
    if (n.tag === \\"argument\\" && f.Argument) return f.Argument(n);
    if (n.tag === \\"body\\" && f.Body) return f.Body(n);
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using purify 1`] = `
Object {
  "bases": Map {},
  "externs": Set {},
  "leaves": Map {
    "FunctionDef" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "args" => Object {
          "struct": "array",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Argument",
            ],
          },
        },
        "body" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Body",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "FunctionDef",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "functiondef",
    },
    "Declaration" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "init" => Object {
          "struct": "optional",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Declaration",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "declaration",
    },
    "Argument" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Argument",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "argument",
    },
    "Body" => Object {
      "bases": Array [],
      "fields": Map {
        "statement" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Statement",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "Body",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "body",
    },
    "AssignmentStatement" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
        "init" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "AssignmentStatement",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "assignmentstatement",
    },
    "DeclarationStatement" => Object {
      "bases": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "string",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "DeclarationStatement",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Node",
        "subtypes": Array [],
      },
      "tag": "declarationstatement",
    },
  },
  "names": Set {
    "Node",
    "FunctionDef",
    "Declaration",
    "Argument",
    "Body",
    "Statement",
    "AssignmentStatement",
    "DeclarationStatement",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "purify",
    "tagName": "tag",
  },
  "unions": Map {
    "Statement" => Object {
      "kind": "astuniontype",
      "name": "Statement",
      "subtypes": Array [
        "AssignmentStatement",
        "DeclarationStatement",
      ],
    },
    "Node" => Object {
      "kind": "astuniontype",
      "name": "Node",
      "subtypes": Array [
        "FunctionDef",
        "Declaration",
        "Argument",
        "Body",
        "Statement",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using purify 2`] = `
"import { Maybe } from \\"purify-ts/Maybe\\";
/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the leaf type FunctionDef.
 **/
export interface FunctionDef {
  tag: \\"functiondef\\";
  name: string;
  args: Argument[];
  body: Body;
}
export class FunctionDef {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of FunctionDef
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is FunctionDef => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 4) return false;
    if (!keys.includes(\\"name\\")) return false;
    if (!keys.includes(\\"args\\")) return false;
    if (!keys.includes(\\"body\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"functiondef\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of FunctionDef
   **/
  static is = (x: Node): x is FunctionDef => {
    return x.tag === \\"functiondef\\";
  };
  /**
   * Given an instance of FunctionDef, determine all children that are instances of Node
   **/
  static children = (x: FunctionDef) => {
    return [x.body, ...x.args] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of FunctionDef
   **/
  static tag = \\"functiondef\\";
}
/**
 * This function can be invoked to create a new instance of FunctionDef
 **/
export function functionDef(
  name: string,
  args: Argument[],
  body: Body
): FunctionDef {
  return { tag: \\"functiondef\\", name, args, body };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Declaration.
 **/
export interface Declaration {
  tag: \\"declaration\\";
  name: string;
  type: string;
  init: Maybe<number>;
}
export class Declaration {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Declaration
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Declaration => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 4) return false;
    if (!keys.includes(\\"name\\")) return false;
    if (!keys.includes(\\"type\\")) return false;
    if (!keys.includes(\\"init\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"declaration\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Declaration
   **/
  static is = (x: Node): x is Declaration => {
    return x.tag === \\"declaration\\";
  };
  /**
   * Given an instance of Declaration, determine all children that are instances of Node
   **/
  static children = (x: Declaration) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Declaration
   **/
  static tag = \\"declaration\\";
}
/**
 * This function can be invoked to create a new instance of Declaration
 **/
export function declaration(
  name: string,
  type: string,
  init: Maybe<number>
): Declaration {
  return { tag: \\"declaration\\", name, type, init };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Argument.
 **/
export interface Argument {
  tag: \\"argument\\";
  name: string;
  type: string;
}
export class Argument {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Argument
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Argument => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 3) return false;
    if (!keys.includes(\\"name\\")) return false;
    if (!keys.includes(\\"type\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"argument\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Argument
   **/
  static is = (x: Node): x is Argument => {
    return x.tag === \\"argument\\";
  };
  /**
   * Given an instance of Argument, determine all children that are instances of Node
   **/
  static children = (x: Argument) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Argument
   **/
  static tag = \\"argument\\";
}
/**
 * This function can be invoked to create a new instance of Argument
 **/
export function argument(name: string, type: string): Argument {
  return { tag: \\"argument\\", name, type };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Body.
 **/
export interface Body {
  tag: \\"body\\";
  statement: Statement;
}
export class Body {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Body
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Body => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"statement\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"body\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of Body
   **/
  static is = (x: Node): x is Body => {
    return x.tag === \\"body\\";
  };
  /**
   * Given an instance of Body, determine all children that are instances of Node
   **/
  static children = (x: Body) => {
    return [x.statement] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Body
   **/
  static tag = \\"body\\";
}
/**
 * This function can be invoked to create a new instance of Body
 **/
export function body(statement: Statement): Body {
  return { tag: \\"body\\", statement };
}

/**
 * This code implements the types and functions associated with
 * the leaf type AssignmentStatement.
 **/
export interface AssignmentStatement {
  tag: \\"assignmentstatement\\";
  name: string;
  init: number;
}
export class AssignmentStatement {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of AssignmentStatement
   **/
  static anyIs = (
    x: any,
    allowExtra: boolean = false
  ): x is AssignmentStatement => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 3) return false;
    if (!keys.includes(\\"name\\")) return false;
    if (!keys.includes(\\"init\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"assignmentstatement\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of AssignmentStatement
   **/
  static is = (x: Node): x is AssignmentStatement => {
    return x.tag === \\"assignmentstatement\\";
  };
  /**
   * Given an instance of AssignmentStatement, determine all children that are instances of Node
   **/
  static children = (x: AssignmentStatement) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of AssignmentStatement
   **/
  static tag = \\"assignmentstatement\\";
}
/**
 * This function can be invoked to create a new instance of AssignmentStatement
 **/
export function assignmentStatement(
  name: string,
  init: number
): AssignmentStatement {
  return { tag: \\"assignmentstatement\\", name, init };
}

/**
 * This code implements the types and functions associated with
 * the leaf type DeclarationStatement.
 **/
export interface DeclarationStatement {
  tag: \\"declarationstatement\\";
  name: string;
}
export class DeclarationStatement {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of DeclarationStatement
   **/
  static anyIs = (
    x: any,
    allowExtra: boolean = false
  ): x is DeclarationStatement => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"name\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"declarationstatement\\";
  };
  /**
   * A predicate function that take an instance of type Node and determines if it is an instance of DeclarationStatement
   **/
  static is = (x: Node): x is DeclarationStatement => {
    return x.tag === \\"declarationstatement\\";
  };
  /**
   * Given an instance of DeclarationStatement, determine all children that are instances of Node
   **/
  static children = (x: DeclarationStatement) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of DeclarationStatement
   **/
  static tag = \\"declarationstatement\\";
}
/**
 * This function can be invoked to create a new instance of DeclarationStatement
 **/
export function declarationStatement(name: string): DeclarationStatement {
  return { tag: \\"declarationstatement\\", name };
}

/**
 * This code implements the types and functions associated with
 * the union type Statement.
 **/
export type Statement = AssignmentStatement | DeclarationStatement;
export namespace Statement {
  /**
   * Given an instance of \`any\` determine it is an instance of any of the leaf types of Statement
   **/
  export const anyIs = (n: any): n is Statement => {
    if (AssignmentStatement.anyIs(n)) return true;
    if (DeclarationStatement.anyIs(n)) return true;
    return false;
  };
  /**
   * Given an instance of Statement, return a list of all children
   **/
  export const children = (n: Statement): readonly Statement[] =>
    map(n, {
      AssignmentStatement: (c): readonly Statement[] =>
        AssignmentStatement.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      DeclarationStatement: (c): readonly Statement[] =>
        DeclarationStatement.children(c)
          .map((x) => x as any)
          .filter(anyIs),
    });
  /**
   * Given an instance of type Statement, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Statement,
    f: {
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Statement has unexpected value for tag: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Statement, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Statement,
    f: Partial<{
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    return orElse;
  };
  /**
   * Given an instance of type Statement, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Statement,
    f: {
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Statement has unexpected value for tag: \\" +
            (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Statement, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Statement,
    f: Partial<{
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }>,
    orElse?: (n: Statement) => void
  ) => {
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    if (orElse) return orElse(n);
  };
}

/**
 * This code implements the types and functions associated with
 * the union type Node.
 **/
export type Node = FunctionDef | Declaration | Argument | Body | Statement;
export namespace Node {
  /**
   * Given an instance of \`any\` determine it is an instance of any of the leaf types of Node
   **/
  export const anyIs = (n: any): n is Node => {
    if (FunctionDef.anyIs(n)) return true;
    if (Declaration.anyIs(n)) return true;
    if (Argument.anyIs(n)) return true;
    if (Body.anyIs(n)) return true;
    if (AssignmentStatement.anyIs(n)) return true;
    if (DeclarationStatement.anyIs(n)) return true;
    return false;
  };
  /**
   * Given an instance of Node, return a list of all children
   **/
  export const children = (n: Node): readonly Node[] =>
    map(n, {
      FunctionDef: (c): readonly Node[] =>
        FunctionDef.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      Declaration: (c): readonly Node[] =>
        Declaration.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      Argument: (c): readonly Node[] =>
        Argument.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      Body: (c): readonly Node[] =>
        Body.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      AssignmentStatement: (c): readonly Node[] =>
        AssignmentStatement.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      DeclarationStatement: (c): readonly Node[] =>
        DeclarationStatement.children(c)
          .map((x) => x as any)
          .filter(anyIs),
    });
  /**
   * Given an instance of type Node, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Node,
    f: {
      FunctionDef: (n: FunctionDef) => R;
      Declaration: (n: Declaration) => R;
      Argument: (n: Argument) => R;
      Body: (n: Body) => R;
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"functiondef\\":
        return f.FunctionDef(n);
      case \\"declaration\\":
        return f.Declaration(n);
      case \\"argument\\":
        return f.Argument(n);
      case \\"body\\":
        return f.Body(n);
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Node has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Node, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Node,
    f: Partial<{
      FunctionDef: (n: FunctionDef) => R;
      Declaration: (n: Declaration) => R;
      Argument: (n: Argument) => R;
      Body: (n: Body) => R;
      AssignmentStatement: (n: AssignmentStatement) => R;
      DeclarationStatement: (n: DeclarationStatement) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"functiondef\\" && f.FunctionDef) return f.FunctionDef(n);
    if (n.tag === \\"declaration\\" && f.Declaration) return f.Declaration(n);
    if (n.tag === \\"argument\\" && f.Argument) return f.Argument(n);
    if (n.tag === \\"body\\" && f.Body) return f.Body(n);
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    return orElse;
  };
  /**
   * Given an instance of type Node, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Node,
    f: {
      FunctionDef: (n: FunctionDef) => void;
      Declaration: (n: Declaration) => void;
      Argument: (n: Argument) => void;
      Body: (n: Body) => void;
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"functiondef\\":
        return f.FunctionDef(n);
      case \\"declaration\\":
        return f.Declaration(n);
      case \\"argument\\":
        return f.Argument(n);
      case \\"body\\":
        return f.Body(n);
      case \\"assignmentstatement\\":
        return f.AssignmentStatement(n);
      case \\"declarationstatement\\":
        return f.DeclarationStatement(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Node has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Node, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Node,
    f: Partial<{
      FunctionDef: (n: FunctionDef) => void;
      Declaration: (n: Declaration) => void;
      Argument: (n: Argument) => void;
      Body: (n: Body) => void;
      AssignmentStatement: (n: AssignmentStatement) => void;
      DeclarationStatement: (n: DeclarationStatement) => void;
    }>,
    orElse?: (n: Node) => void
  ) => {
    if (n.tag === \\"functiondef\\" && f.FunctionDef) return f.FunctionDef(n);
    if (n.tag === \\"declaration\\" && f.Declaration) return f.Declaration(n);
    if (n.tag === \\"argument\\" && f.Argument) return f.Argument(n);
    if (n.tag === \\"body\\" && f.Body) return f.Body(n);
    if (n.tag === \\"assignmentstatement\\" && f.AssignmentStatement)
      return f.AssignmentStatement(n);
    if (n.tag === \\"declarationstatement\\" && f.DeclarationStatement)
      return f.DeclarationStatement(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using json 1`] = `
Object {
  "bases": Map {},
  "externs": Set {},
  "leaves": Map {
    "Fork" => Object {
      "bases": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Tree",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Tree",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "Fork",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Tree",
        "subtypes": Array [],
      },
      "tag": "fork",
    },
    "Leaf" => Object {
      "bases": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Leaf",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Tree",
        "subtypes": Array [],
      },
      "tag": "leaf",
    },
  },
  "names": Set {
    "Tree",
    "Fork",
    "Leaf",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "json",
    "tagName": "tag",
  },
  "unions": Map {
    "Tree" => Object {
      "kind": "astuniontype",
      "name": "Tree",
      "subtypes": Array [
        "Fork",
        "Leaf",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using json 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the leaf type Fork.
 **/
export interface Fork {
  tag: \\"fork\\";
  left: Tree;
  right: Tree;
}
export class Fork {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Fork
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Fork => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 3) return false;
    if (!keys.includes(\\"left\\")) return false;
    if (!keys.includes(\\"right\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"fork\\";
  };
  /**
   * A predicate function that take an instance of type Tree and determines if it is an instance of Fork
   **/
  static is = (x: Tree): x is Fork => {
    return x.tag === \\"fork\\";
  };
  /**
   * Given an instance of Fork, determine all children that are instances of Tree
   **/
  static children = (x: Fork) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Fork
   **/
  static tag = \\"fork\\";
}
/**
 * This function can be invoked to create a new instance of Fork
 **/
export function fork(left: Tree, right: Tree): Fork {
  return { tag: \\"fork\\", left, right };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Leaf.
 **/
export interface Leaf {
  tag: \\"leaf\\";
  value: number;
}
export class Leaf {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Leaf
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Leaf => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"value\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"leaf\\";
  };
  /**
   * A predicate function that take an instance of type Tree and determines if it is an instance of Leaf
   **/
  static is = (x: Tree): x is Leaf => {
    return x.tag === \\"leaf\\";
  };
  /**
   * Given an instance of Leaf, determine all children that are instances of Tree
   **/
  static children = (x: Leaf) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Leaf
   **/
  static tag = \\"leaf\\";
}
/**
 * This function can be invoked to create a new instance of Leaf
 **/
export function leaf(value: number): Leaf {
  return { tag: \\"leaf\\", value };
}

/**
 * This code implements the types and functions associated with
 * the union type Tree.
 **/
export type Tree = Fork | Leaf;
export namespace Tree {
  /**
   * Given an instance of \`any\` determine it is an instance of any of the leaf types of Tree
   **/
  export const anyIs = (n: any): n is Tree => {
    if (Fork.anyIs(n)) return true;
    if (Leaf.anyIs(n)) return true;
    return false;
  };
  /**
   * Given an instance of Tree, return a list of all children
   **/
  export const children = (n: Tree): readonly Tree[] =>
    map(n, {
      Fork: (c): readonly Tree[] =>
        Fork.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      Leaf: (c): readonly Tree[] =>
        Leaf.children(c)
          .map((x) => x as any)
          .filter(anyIs),
    });
  /**
   * Given an instance of type Tree, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Tree,
    f: {
      Fork: (n: Fork) => R;
      Leaf: (n: Leaf) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"fork\\":
        return f.Fork(n);
      case \\"leaf\\":
        return f.Leaf(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Tree has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Tree, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Tree,
    f: Partial<{
      Fork: (n: Fork) => R;
      Leaf: (n: Leaf) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"fork\\" && f.Fork) return f.Fork(n);
    if (n.tag === \\"leaf\\" && f.Leaf) return f.Leaf(n);
    return orElse;
  };
  /**
   * Given an instance of type Tree, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Tree,
    f: {
      Fork: (n: Fork) => void;
      Leaf: (n: Leaf) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"fork\\":
        return f.Fork(n);
      case \\"leaf\\":
        return f.Leaf(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Tree has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Tree, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Tree,
    f: Partial<{
      Fork: (n: Fork) => void;
      Leaf: (n: Leaf) => void;
    }>,
    orElse?: (n: Tree) => void
  ) => {
    if (n.tag === \\"fork\\" && f.Fork) return f.Fork(n);
    if (n.tag === \\"leaf\\" && f.Leaf) return f.Leaf(n);
    if (orElse) return orElse(n);
  };
}
"
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using purify 1`] = `
Object {
  "bases": Map {},
  "externs": Set {},
  "leaves": Map {
    "Fork" => Object {
      "bases": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Tree",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "nodetype",
            "types": Array [
              "Tree",
            ],
          },
        },
      },
      "kind": "astleaftype",
      "name": "Fork",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Tree",
        "subtypes": Array [],
      },
      "tag": "fork",
    },
    "Leaf" => Object {
      "bases": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtintype",
            "types": Set {
              "number",
            },
          },
        },
      },
      "kind": "astleaftype",
      "name": "Leaf",
      "rootUnion": Object {
        "kind": "astuniontype",
        "name": "Tree",
        "subtypes": Array [],
      },
      "tag": "leaf",
    },
  },
  "names": Set {
    "Tree",
    "Fork",
    "Leaf",
  },
  "options": Object {
    "constructor": "inline",
    "maps": "json",
    "optional": "purify",
    "tagName": "tag",
  },
  "unions": Map {
    "Tree" => Object {
      "kind": "astuniontype",
      "name": "Tree",
      "subtypes": Array [
        "Fork",
        "Leaf",
      ],
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using purify 2`] = `
"/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

/**
 * This code implements the types and functions associated with
 * the leaf type Fork.
 **/
export interface Fork {
  tag: \\"fork\\";
  left: Tree;
  right: Tree;
}
export class Fork {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Fork
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Fork => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 3) return false;
    if (!keys.includes(\\"left\\")) return false;
    if (!keys.includes(\\"right\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"fork\\";
  };
  /**
   * A predicate function that take an instance of type Tree and determines if it is an instance of Fork
   **/
  static is = (x: Tree): x is Fork => {
    return x.tag === \\"fork\\";
  };
  /**
   * Given an instance of Fork, determine all children that are instances of Tree
   **/
  static children = (x: Fork) => {
    return [x.left, x.right] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Fork
   **/
  static tag = \\"fork\\";
}
/**
 * This function can be invoked to create a new instance of Fork
 **/
export function fork(left: Tree, right: Tree): Fork {
  return { tag: \\"fork\\", left, right };
}

/**
 * This code implements the types and functions associated with
 * the leaf type Leaf.
 **/
export interface Leaf {
  tag: \\"leaf\\";
  value: number;
}
export class Leaf {
  /**
   * A predicate function that take an instance of \`any\` and determines if it is an instance of Leaf
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is Leaf => {
    if (x === null || x === undefined) return false;
    if (typeof x !== \\"object\\") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes(\\"value\\")) return false;
    if (!keys.includes(\\"tag\\")) return false;
    return x.tag === \\"leaf\\";
  };
  /**
   * A predicate function that take an instance of type Tree and determines if it is an instance of Leaf
   **/
  static is = (x: Tree): x is Leaf => {
    return x.tag === \\"leaf\\";
  };
  /**
   * Given an instance of Leaf, determine all children that are instances of Tree
   **/
  static children = (x: Leaf) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of Leaf
   **/
  static tag = \\"leaf\\";
}
/**
 * This function can be invoked to create a new instance of Leaf
 **/
export function leaf(value: number): Leaf {
  return { tag: \\"leaf\\", value };
}

/**
 * This code implements the types and functions associated with
 * the union type Tree.
 **/
export type Tree = Fork | Leaf;
export namespace Tree {
  /**
   * Given an instance of \`any\` determine it is an instance of any of the leaf types of Tree
   **/
  export const anyIs = (n: any): n is Tree => {
    if (Fork.anyIs(n)) return true;
    if (Leaf.anyIs(n)) return true;
    return false;
  };
  /**
   * Given an instance of Tree, return a list of all children
   **/
  export const children = (n: Tree): readonly Tree[] =>
    map(n, {
      Fork: (c): readonly Tree[] =>
        Fork.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      Leaf: (c): readonly Tree[] =>
        Leaf.children(c)
          .map((x) => x as any)
          .filter(anyIs),
    });
  /**
   * Given an instance of type Tree, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: Tree,
    f: {
      Fork: (n: Fork) => R;
      Leaf: (n: Leaf) => R;
    }
  ) => {
    switch (n.tag) {
      case \\"fork\\":
        return f.Fork(n);
      case \\"leaf\\":
        return f.Leaf(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Tree has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Tree, map that value for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMap = <R>(
    n: Tree,
    f: Partial<{
      Fork: (n: Fork) => R;
      Leaf: (n: Leaf) => R;
    }>,
    orElse: R
  ) => {
    if (n.tag === \\"fork\\" && f.Fork) return f.Fork(n);
    if (n.tag === \\"leaf\\" && f.Leaf) return f.Leaf(n);
    return orElse;
  };
  /**
   * Given an instance of type Tree, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: Tree,
    f: {
      Fork: (n: Fork) => void;
      Leaf: (n: Leaf) => void;
    }
  ): void => {
    switch (n.tag) {
      case \\"fork\\":
        return f.Fork(n);
      case \\"leaf\\":
        return f.Leaf(n);
      default: {
        const x: never = n;
        throw new Error(
          \\"Instance of Tree has unexpected value for tag: \\" + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type Tree, take action for certain subtypes
   * and for all others, simply return the \`orElse\` argument
   **/
  export const partialMatch = (
    n: Tree,
    f: Partial<{
      Fork: (n: Fork) => void;
      Leaf: (n: Leaf) => void;
    }>,
    orElse?: (n: Tree) => void
  ) => {
    if (n.tag === \\"fork\\" && f.Fork) return f.Fork(n);
    if (n.tag === \\"leaf\\" && f.Leaf) return f.Leaf(n);
    if (orElse) return orElse(n);
  };
}
"
`;
