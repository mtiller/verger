// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Test sample AST specifications should generate proper output for dogfood.yaml using json 1`] = `
Object {
  "bases": Map {},
  "leaves": Map {
    "BuiltinType" => Object {
      "extends": Array [],
      "fields": Map {
        "types" => Object {
          "struct": "set",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "str",
              "num",
              "bool",
            ],
          },
        },
      },
      "name": "BuiltinType",
      "rootUnion": "FieldType",
      "tag": "builtintype",
      "type": "leaf",
    },
    "EnumType" => Object {
      "extends": Array [],
      "fields": Map {
        "tags" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
      },
      "name": "EnumType",
      "rootUnion": "FieldType",
      "tag": "enumtype",
      "type": "leaf",
    },
    "NodeType" => Object {
      "extends": Array [],
      "fields": Map {
        "types" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
      },
      "name": "NodeType",
      "rootUnion": "FieldType",
      "tag": "nodetype",
      "type": "leaf",
    },
    "Field" => Object {
      "extends": Array [],
      "fields": Map {
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "FieldType",
            ],
          },
        },
        "struct" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "scalar",
              "optional",
              "map",
              "set",
              "array",
            ],
          },
        },
      },
      "name": "Field",
      "rootUnion": "Field",
      "tag": "field",
      "type": "leaf",
    },
    "NodeField" => Object {
      "extends": Array [],
      "fields": Map {
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "NodeType",
            ],
          },
        },
        "struct" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "FieldStruct",
            ],
          },
        },
      },
      "name": "NodeField",
      "rootUnion": "NodeField",
      "tag": "nodefield",
      "type": "leaf",
    },
    "ASTUnionType" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "subtypes" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
      },
      "name": "ASTUnionType",
      "rootUnion": "ASTTree",
      "tag": "astuniontype",
      "type": "leaf",
    },
    "ASTLeafType" => Object {
      "extends": Array [],
      "fields": Map {
        "kind" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "rootUnion" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "bases" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "fields" => Object {
          "struct": "map",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Field",
            ],
          },
        },
      },
      "name": "ASTLeafType",
      "rootUnion": "ASTTree",
      "tag": "astleaftype",
      "type": "leaf",
    },
  },
  "names": Set {
    "FieldType",
    "BuiltinType",
    "EnumType",
    "NodeType",
    "Field",
    "NodeField",
    "ASTTree",
    "ASTUnionType",
    "ASTLeafType",
  },
  "options": Object {
    "maps": "json",
    "optional": "json",
  },
  "tagName": "tag",
  "unions": Map {
    "FieldType" => Object {
      "name": "FieldType",
      "subtypes": Array [
        "BuiltinType",
        "EnumType",
        "NodeType",
      ],
      "type": "union",
    },
    "ASTTree" => Object {
      "name": "ASTTree",
      "subtypes": Array [
        "ASTUnionType",
        "ASTLeafType",
      ],
      "type": "union",
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for dogfood.yaml using json 2`] = `
"// DO NOT EDIT
// This file was automatically generated


export interface BuiltinType  {
    tag: \\"builtintype\\";
    types: Set<\\"str\\" | \\"num\\" | \\"bool\\">;
}
export class BuiltinType {
    static is = (x: FieldType): x is BuiltinType => { return x.tag===\\"builtintype\\" }
    static children = (x: BuiltinType) => { return [] as const }
    static tag = \\"builtintype\\"
}
export interface EnumType  {
    tag: \\"enumtype\\";
    tags: string[];
}
export class EnumType {
    static is = (x: FieldType): x is EnumType => { return x.tag===\\"enumtype\\" }
    static children = (x: EnumType) => { return [] as const }
    static tag = \\"enumtype\\"
}
export interface NodeType  {
    tag: \\"nodetype\\";
    types: string[];
}
export class NodeType {
    static is = (x: FieldType): x is NodeType => { return x.tag===\\"nodetype\\" }
    static children = (x: NodeType) => { return [] as const }
    static tag = \\"nodetype\\"
}
export interface Field  {
    tag: \\"field\\";
    type: FieldType;
    struct: \\"scalar\\" | \\"optional\\" | \\"map\\" | \\"set\\" | \\"array\\";
}
export class Field {
    static is = (x: Field): x is Field => { return x.tag===\\"field\\" }
    static children = (x: Field) => { return [x.type] as const }
    static tag = \\"field\\"
}
export interface NodeField  {
    tag: \\"nodefield\\";
    type: NodeType;
    struct: \\"FieldStruct\\";
}
export class NodeField {
    static is = (x: NodeField): x is NodeField => { return x.tag===\\"nodefield\\" }
    static children = (x: NodeField) => { return [x.type] as const }
    static tag = \\"nodefield\\"
}
export interface ASTUnionType  {
    tag: \\"astuniontype\\";
    name: string;
    subtypes: string[];
}
export class ASTUnionType {
    static is = (x: ASTTree): x is ASTUnionType => { return x.tag===\\"astuniontype\\" }
    static children = (x: ASTUnionType) => { return [] as const }
    static tag = \\"astuniontype\\"
}
export interface ASTLeafType  {
    tag: \\"astleaftype\\";
    kind: string;
    rootUnion: string;
    name: string;
    bases: string[];
    fields: Record<string,Field>;
}
export class ASTLeafType {
    static is = (x: ASTTree): x is ASTLeafType => { return x.tag===\\"astleaftype\\" }
    static children = (x: ASTLeafType) => { return [...Object.entries(x.fields).map(x => x[1])] as const }
    static tag = \\"astleaftype\\"
}
export type FieldType = BuiltinType | EnumType | NodeType;
namespace FieldType {
  export const match = <R>(n: FieldType, f: {
    BuiltinType: (n: BuiltinType) => R
    EnumType: (n: EnumType) => R
    NodeType: (n: NodeType) => R
}) => {
    switch(n.tag) {
      case \\"builtintype\\": return f.BuiltinType(n)
      case \\"enumtype\\": return f.EnumType(n)
      case \\"nodetype\\": return f.NodeType(n)
      default: { const x: never = n; throw new Error(\\"Instance of FieldType has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
}
export type ASTTree = ASTUnionType | ASTLeafType;
namespace ASTTree {
  export const match = <R>(n: ASTTree, f: {
    ASTUnionType: (n: ASTUnionType) => R
    ASTLeafType: (n: ASTLeafType) => R
}) => {
    switch(n.tag) {
      case \\"astuniontype\\": return f.ASTUnionType(n)
      case \\"astleaftype\\": return f.ASTLeafType(n)
      default: { const x: never = n; throw new Error(\\"Instance of ASTTree has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
}"
`;

exports[`Test sample AST specifications should generate proper output for dogfood.yaml using purify 1`] = `
Object {
  "bases": Map {},
  "leaves": Map {
    "BuiltinType" => Object {
      "extends": Array [],
      "fields": Map {
        "types" => Object {
          "struct": "set",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "str",
              "num",
              "bool",
            ],
          },
        },
      },
      "name": "BuiltinType",
      "rootUnion": "FieldType",
      "tag": "builtintype",
      "type": "leaf",
    },
    "EnumType" => Object {
      "extends": Array [],
      "fields": Map {
        "tags" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
      },
      "name": "EnumType",
      "rootUnion": "FieldType",
      "tag": "enumtype",
      "type": "leaf",
    },
    "NodeType" => Object {
      "extends": Array [],
      "fields": Map {
        "types" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
      },
      "name": "NodeType",
      "rootUnion": "FieldType",
      "tag": "nodetype",
      "type": "leaf",
    },
    "Field" => Object {
      "extends": Array [],
      "fields": Map {
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "FieldType",
            ],
          },
        },
        "struct" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "scalar",
              "optional",
              "map",
              "set",
              "array",
            ],
          },
        },
      },
      "name": "Field",
      "rootUnion": "Field",
      "tag": "field",
      "type": "leaf",
    },
    "NodeField" => Object {
      "extends": Array [],
      "fields": Map {
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "NodeType",
            ],
          },
        },
        "struct" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "FieldStruct",
            ],
          },
        },
      },
      "name": "NodeField",
      "rootUnion": "NodeField",
      "tag": "nodefield",
      "type": "leaf",
    },
    "ASTUnionType" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "subtypes" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
      },
      "name": "ASTUnionType",
      "rootUnion": "ASTTree",
      "tag": "astuniontype",
      "type": "leaf",
    },
    "ASTLeafType" => Object {
      "extends": Array [],
      "fields": Map {
        "kind" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "rootUnion" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "bases" => Object {
          "struct": "array",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "fields" => Object {
          "struct": "map",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Field",
            ],
          },
        },
      },
      "name": "ASTLeafType",
      "rootUnion": "ASTTree",
      "tag": "astleaftype",
      "type": "leaf",
    },
  },
  "names": Set {
    "FieldType",
    "BuiltinType",
    "EnumType",
    "NodeType",
    "Field",
    "NodeField",
    "ASTTree",
    "ASTUnionType",
    "ASTLeafType",
  },
  "options": Object {
    "maps": "json",
    "optional": "purify",
  },
  "tagName": "tag",
  "unions": Map {
    "FieldType" => Object {
      "name": "FieldType",
      "subtypes": Array [
        "BuiltinType",
        "EnumType",
        "NodeType",
      ],
      "type": "union",
    },
    "ASTTree" => Object {
      "name": "ASTTree",
      "subtypes": Array [
        "ASTUnionType",
        "ASTLeafType",
      ],
      "type": "union",
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for dogfood.yaml using purify 2`] = `
"// DO NOT EDIT
// This file was automatically generated


export interface BuiltinType  {
    tag: \\"builtintype\\";
    types: Set<\\"str\\" | \\"num\\" | \\"bool\\">;
}
export class BuiltinType {
    static is = (x: FieldType): x is BuiltinType => { return x.tag===\\"builtintype\\" }
    static children = (x: BuiltinType) => { return [] as const }
    static tag = \\"builtintype\\"
}
export interface EnumType  {
    tag: \\"enumtype\\";
    tags: string[];
}
export class EnumType {
    static is = (x: FieldType): x is EnumType => { return x.tag===\\"enumtype\\" }
    static children = (x: EnumType) => { return [] as const }
    static tag = \\"enumtype\\"
}
export interface NodeType  {
    tag: \\"nodetype\\";
    types: string[];
}
export class NodeType {
    static is = (x: FieldType): x is NodeType => { return x.tag===\\"nodetype\\" }
    static children = (x: NodeType) => { return [] as const }
    static tag = \\"nodetype\\"
}
export interface Field  {
    tag: \\"field\\";
    type: FieldType;
    struct: \\"scalar\\" | \\"optional\\" | \\"map\\" | \\"set\\" | \\"array\\";
}
export class Field {
    static is = (x: Field): x is Field => { return x.tag===\\"field\\" }
    static children = (x: Field) => { return [x.type] as const }
    static tag = \\"field\\"
}
export interface NodeField  {
    tag: \\"nodefield\\";
    type: NodeType;
    struct: \\"FieldStruct\\";
}
export class NodeField {
    static is = (x: NodeField): x is NodeField => { return x.tag===\\"nodefield\\" }
    static children = (x: NodeField) => { return [x.type] as const }
    static tag = \\"nodefield\\"
}
export interface ASTUnionType  {
    tag: \\"astuniontype\\";
    name: string;
    subtypes: string[];
}
export class ASTUnionType {
    static is = (x: ASTTree): x is ASTUnionType => { return x.tag===\\"astuniontype\\" }
    static children = (x: ASTUnionType) => { return [] as const }
    static tag = \\"astuniontype\\"
}
export interface ASTLeafType  {
    tag: \\"astleaftype\\";
    kind: string;
    rootUnion: string;
    name: string;
    bases: string[];
    fields: Record<string,Field>;
}
export class ASTLeafType {
    static is = (x: ASTTree): x is ASTLeafType => { return x.tag===\\"astleaftype\\" }
    static children = (x: ASTLeafType) => { return [...Object.entries(x.fields).map(x => x[1])] as const }
    static tag = \\"astleaftype\\"
}
export type FieldType = BuiltinType | EnumType | NodeType;
namespace FieldType {
  export const match = <R>(n: FieldType, f: {
    BuiltinType: (n: BuiltinType) => R
    EnumType: (n: EnumType) => R
    NodeType: (n: NodeType) => R
}) => {
    switch(n.tag) {
      case \\"builtintype\\": return f.BuiltinType(n)
      case \\"enumtype\\": return f.EnumType(n)
      case \\"nodetype\\": return f.NodeType(n)
      default: { const x: never = n; throw new Error(\\"Instance of FieldType has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
}
export type ASTTree = ASTUnionType | ASTLeafType;
namespace ASTTree {
  export const match = <R>(n: ASTTree, f: {
    ASTUnionType: (n: ASTUnionType) => R
    ASTLeafType: (n: ASTLeafType) => R
}) => {
    switch(n.tag) {
      case \\"astuniontype\\": return f.ASTUnionType(n)
      case \\"astleaftype\\": return f.ASTLeafType(n)
      default: { const x: never = n; throw new Error(\\"Instance of ASTTree has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
}"
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using json 1`] = `
Object {
  "bases": Map {
    "BinaryOp" => Object {
      "extends": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Expr",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Expr",
            ],
          },
        },
      },
      "name": "BinaryOp",
    },
  },
  "leaves": Map {
    "Literal" => Object {
      "extends": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "number",
            ],
          },
        },
      },
      "name": "Literal",
      "rootUnion": "Expr",
      "tag": "literal",
      "type": "leaf",
    },
    "ArithmeticOp" => Object {
      "extends": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "+",
              "-",
              "*",
              "/",
            ],
          },
        },
      },
      "name": "ArithmeticOp",
      "rootUnion": "Expr",
      "tag": "arithmeticop",
      "type": "leaf",
    },
    "UnaryOp" => Object {
      "extends": Array [],
      "fields": Map {
        "expr" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Expr",
            ],
          },
        },
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "()",
              "+",
              "-",
            ],
          },
        },
      },
      "name": "UnaryOp",
      "rootUnion": "Expr",
      "tag": "unaryop",
      "type": "leaf",
    },
    "RelOp" => Object {
      "extends": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "+",
              "-",
              "*",
              "/",
            ],
          },
        },
      },
      "name": "RelOp",
      "rootUnion": "Expr",
      "tag": "relop",
      "type": "leaf",
    },
  },
  "names": Set {
    "Expr",
    "Literal",
    "ArithmeticOp",
    "UnaryOp",
    "RelOp",
    "BinaryOp",
  },
  "options": Object {
    "maps": "json",
    "optional": "json",
    "tagName": "tag",
  },
  "unions": Map {
    "Expr" => Object {
      "name": "Expr",
      "subtypes": Array [
        "Literal",
        "ArithmeticOp",
        "UnaryOp",
        "RelOp",
      ],
      "type": "union",
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using json 2`] = `
"// DO NOT EDIT
// This file was automatically generated

export interface BinaryOp  {
    left: Expr;
    right: Expr;
}
export interface Literal  {
    tag: \\"literal\\";
    value: number;
}
export class Literal {
    static is = (x: Expr): x is Literal => { return x.tag===\\"literal\\" }
    static children = (x: Literal) => { return [] as const }
    static tag = \\"literal\\"
}
export interface ArithmeticOp extends BinaryOp {
    tag: \\"arithmeticop\\";
    op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\";
}
export class ArithmeticOp {
    static is = (x: Expr): x is ArithmeticOp => { return x.tag===\\"arithmeticop\\" }
    static children = (x: ArithmeticOp) => { return [x.left, x.right] as const }
    static tag = \\"arithmeticop\\"
}
export interface UnaryOp  {
    tag: \\"unaryop\\";
    expr: Expr;
    op: \\"()\\" | \\"+\\" | \\"-\\";
}
export class UnaryOp {
    static is = (x: Expr): x is UnaryOp => { return x.tag===\\"unaryop\\" }
    static children = (x: UnaryOp) => { return [x.expr] as const }
    static tag = \\"unaryop\\"
}
export interface RelOp extends BinaryOp {
    tag: \\"relop\\";
    op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\";
}
export class RelOp {
    static is = (x: Expr): x is RelOp => { return x.tag===\\"relop\\" }
    static children = (x: RelOp) => { return [x.left, x.right] as const }
    static tag = \\"relop\\"
}
export type Expr = Literal | ArithmeticOp | UnaryOp | RelOp;
namespace Expr {
  export const match = <R>(n: Expr, f: {
    Literal: (n: Literal) => R
    ArithmeticOp: (n: ArithmeticOp) => R
    UnaryOp: (n: UnaryOp) => R
    RelOp: (n: RelOp) => R
  }) => {
    switch(n.tag) {
      case \\"literal\\": return f.Literal(n)
      case \\"arithmeticop\\": return f.ArithmeticOp(n)
      case \\"unaryop\\": return f.UnaryOp(n)
      case \\"relop\\": return f.RelOp(n)
      default: { const x: never = n; throw new Error(\\"Instance of Expr has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
  export const partialMatch = <R>(n: Expr, f: Partial<{
    Literal: (n: Literal) => R
    ArithmeticOp: (n: ArithmeticOp) => R
    UnaryOp: (n: UnaryOp) => R
    RelOp: (n: RelOp) => R
  }>, orElse: R) => {
      if (f.Literal) return f.Literal;
      if (f.ArithmeticOp) return f.ArithmeticOp;
      if (f.UnaryOp) return f.UnaryOp;
      if (f.RelOp) return f.RelOp;
      return orElse;
    }
}"
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using purify 1`] = `
Object {
  "bases": Map {
    "BinaryOp" => Object {
      "extends": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Expr",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Expr",
            ],
          },
        },
      },
      "name": "BinaryOp",
    },
  },
  "leaves": Map {
    "Literal" => Object {
      "extends": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "number",
            ],
          },
        },
      },
      "name": "Literal",
      "rootUnion": "Expr",
      "tag": "literal",
      "type": "leaf",
    },
    "ArithmeticOp" => Object {
      "extends": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "+",
              "-",
              "*",
              "/",
            ],
          },
        },
      },
      "name": "ArithmeticOp",
      "rootUnion": "Expr",
      "tag": "arithmeticop",
      "type": "leaf",
    },
    "UnaryOp" => Object {
      "extends": Array [],
      "fields": Map {
        "expr" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Expr",
            ],
          },
        },
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "()",
              "+",
              "-",
            ],
          },
        },
      },
      "name": "UnaryOp",
      "rootUnion": "Expr",
      "tag": "unaryop",
      "type": "leaf",
    },
    "RelOp" => Object {
      "extends": Array [
        "BinaryOp",
      ],
      "fields": Map {
        "op" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "enum",
            "tags": Array [
              "+",
              "-",
              "*",
              "/",
            ],
          },
        },
      },
      "name": "RelOp",
      "rootUnion": "Expr",
      "tag": "relop",
      "type": "leaf",
    },
  },
  "names": Set {
    "Expr",
    "Literal",
    "ArithmeticOp",
    "UnaryOp",
    "RelOp",
    "BinaryOp",
  },
  "options": Object {
    "maps": "json",
    "optional": "purify",
    "tagName": "tag",
  },
  "unions": Map {
    "Expr" => Object {
      "name": "Expr",
      "subtypes": Array [
        "Literal",
        "ArithmeticOp",
        "UnaryOp",
        "RelOp",
      ],
      "type": "union",
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for expr.yaml using purify 2`] = `
"// DO NOT EDIT
// This file was automatically generated

export interface BinaryOp  {
    left: Expr;
    right: Expr;
}
export interface Literal  {
    tag: \\"literal\\";
    value: number;
}
export class Literal {
    static is = (x: Expr): x is Literal => { return x.tag===\\"literal\\" }
    static children = (x: Literal) => { return [] as const }
    static tag = \\"literal\\"
}
export interface ArithmeticOp extends BinaryOp {
    tag: \\"arithmeticop\\";
    op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\";
}
export class ArithmeticOp {
    static is = (x: Expr): x is ArithmeticOp => { return x.tag===\\"arithmeticop\\" }
    static children = (x: ArithmeticOp) => { return [x.left, x.right] as const }
    static tag = \\"arithmeticop\\"
}
export interface UnaryOp  {
    tag: \\"unaryop\\";
    expr: Expr;
    op: \\"()\\" | \\"+\\" | \\"-\\";
}
export class UnaryOp {
    static is = (x: Expr): x is UnaryOp => { return x.tag===\\"unaryop\\" }
    static children = (x: UnaryOp) => { return [x.expr] as const }
    static tag = \\"unaryop\\"
}
export interface RelOp extends BinaryOp {
    tag: \\"relop\\";
    op: \\"+\\" | \\"-\\" | \\"*\\" | \\"/\\";
}
export class RelOp {
    static is = (x: Expr): x is RelOp => { return x.tag===\\"relop\\" }
    static children = (x: RelOp) => { return [x.left, x.right] as const }
    static tag = \\"relop\\"
}
export type Expr = Literal | ArithmeticOp | UnaryOp | RelOp;
namespace Expr {
  export const match = <R>(n: Expr, f: {
    Literal: (n: Literal) => R
    ArithmeticOp: (n: ArithmeticOp) => R
    UnaryOp: (n: UnaryOp) => R
    RelOp: (n: RelOp) => R
  }) => {
    switch(n.tag) {
      case \\"literal\\": return f.Literal(n)
      case \\"arithmeticop\\": return f.ArithmeticOp(n)
      case \\"unaryop\\": return f.UnaryOp(n)
      case \\"relop\\": return f.RelOp(n)
      default: { const x: never = n; throw new Error(\\"Instance of Expr has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
  export const partialMatch = <R>(n: Expr, f: Partial<{
    Literal: (n: Literal) => R
    ArithmeticOp: (n: ArithmeticOp) => R
    UnaryOp: (n: UnaryOp) => R
    RelOp: (n: RelOp) => R
  }>, orElse: R) => {
      if (f.Literal) return f.Literal;
      if (f.ArithmeticOp) return f.ArithmeticOp;
      if (f.UnaryOp) return f.UnaryOp;
      if (f.RelOp) return f.RelOp;
      return orElse;
    }
}"
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using json 1`] = `
Object {
  "bases": Map {},
  "leaves": Map {
    "Function" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "args" => Object {
          "struct": "array",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Argument",
            ],
          },
        },
        "body" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Body",
            ],
          },
        },
      },
      "name": "Function",
      "rootUnion": "Node",
      "tag": "function",
      "type": "leaf",
    },
    "Declaration" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "init" => Object {
          "struct": "optional",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "number",
            ],
          },
        },
      },
      "name": "Declaration",
      "rootUnion": "Node",
      "tag": "declaration",
      "type": "leaf",
    },
    "Argument" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
      },
      "name": "Argument",
      "rootUnion": "Node",
      "tag": "argument",
      "type": "leaf",
    },
    "Body" => Object {
      "extends": Array [],
      "fields": Map {
        "statement" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Statement",
            ],
          },
        },
      },
      "name": "Body",
      "rootUnion": "Node",
      "tag": "body",
      "type": "leaf",
    },
    "AssignmentStatement" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "init" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "number",
            ],
          },
        },
      },
      "name": "AssignmentStatement",
      "rootUnion": "Node",
      "tag": "assignmentstatement",
      "type": "leaf",
    },
    "DeclarationStatement" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
      },
      "name": "DeclarationStatement",
      "rootUnion": "Node",
      "tag": "declarationstatement",
      "type": "leaf",
    },
  },
  "names": Set {
    "Node",
    "Function",
    "Declaration",
    "Argument",
    "Body",
    "Statement",
    "AssignmentStatement",
    "DeclarationStatement",
  },
  "options": Object {
    "maps": "json",
    "optional": "json",
    "tagName": "tag",
  },
  "unions": Map {
    "Statement" => Object {
      "name": "Statement",
      "subtypes": Array [
        "AssignmentStatement",
        "DeclarationStatement",
      ],
      "type": "union",
    },
    "Node" => Object {
      "name": "Node",
      "subtypes": Array [
        "Function",
        "Declaration",
        "Argument",
        "Body",
        "Statement",
      ],
      "type": "union",
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using json 2`] = `
"// DO NOT EDIT
// This file was automatically generated


export interface Function  {
    tag: \\"function\\";
    name: string;
    args: Argument[];
    body: Body;
}
export class Function {
    static is = (x: Node): x is Function => { return x.tag===\\"function\\" }
    static children = (x: Function) => { return [x.body, ...x.args] as const }
    static tag = \\"function\\"
}
export interface Declaration  {
    tag: \\"declaration\\";
    name: string;
    type: string;
    init?: number;
}
export class Declaration {
    static is = (x: Node): x is Declaration => { return x.tag===\\"declaration\\" }
    static children = (x: Declaration) => { return [] as const }
    static tag = \\"declaration\\"
}
export interface Argument  {
    tag: \\"argument\\";
    name: string;
    type: string;
}
export class Argument {
    static is = (x: Node): x is Argument => { return x.tag===\\"argument\\" }
    static children = (x: Argument) => { return [] as const }
    static tag = \\"argument\\"
}
export interface Body  {
    tag: \\"body\\";
    statement: Statement;
}
export class Body {
    static is = (x: Node): x is Body => { return x.tag===\\"body\\" }
    static children = (x: Body) => { return [x.statement] as const }
    static tag = \\"body\\"
}
export interface AssignmentStatement  {
    tag: \\"assignmentstatement\\";
    name: string;
    init: number;
}
export class AssignmentStatement {
    static is = (x: Node): x is AssignmentStatement => { return x.tag===\\"assignmentstatement\\" }
    static children = (x: AssignmentStatement) => { return [] as const }
    static tag = \\"assignmentstatement\\"
}
export interface DeclarationStatement  {
    tag: \\"declarationstatement\\";
    name: string;
}
export class DeclarationStatement {
    static is = (x: Node): x is DeclarationStatement => { return x.tag===\\"declarationstatement\\" }
    static children = (x: DeclarationStatement) => { return [] as const }
    static tag = \\"declarationstatement\\"
}
export type Statement = AssignmentStatement | DeclarationStatement;
namespace Statement {
  export const match = <R>(n: Statement, f: {
    AssignmentStatement: (n: AssignmentStatement) => R
    DeclarationStatement: (n: DeclarationStatement) => R
  }) => {
    switch(n.tag) {
      case \\"assignmentstatement\\": return f.AssignmentStatement(n)
      case \\"declarationstatement\\": return f.DeclarationStatement(n)
      default: { const x: never = n; throw new Error(\\"Instance of Statement has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
  export const partialMatch = <R>(n: Statement, f: Partial<{
    AssignmentStatement: (n: AssignmentStatement) => R
    DeclarationStatement: (n: DeclarationStatement) => R
  }>, orElse: R) => {
      if (f.AssignmentStatement) return f.AssignmentStatement;
      if (f.DeclarationStatement) return f.DeclarationStatement;
      return orElse;
    }
}
export type Node = Function | Declaration | Argument | Body | Statement;
namespace Node {
  export const match = <R>(n: Node, f: {
    Function: (n: Function) => R
    Declaration: (n: Declaration) => R
    Argument: (n: Argument) => R
    Body: (n: Body) => R
    AssignmentStatement: (n: AssignmentStatement) => R
    DeclarationStatement: (n: DeclarationStatement) => R
  }) => {
    switch(n.tag) {
      case \\"function\\": return f.Function(n)
      case \\"declaration\\": return f.Declaration(n)
      case \\"argument\\": return f.Argument(n)
      case \\"body\\": return f.Body(n)
      case \\"assignmentstatement\\": return f.AssignmentStatement(n)
      case \\"declarationstatement\\": return f.DeclarationStatement(n)
      default: { const x: never = n; throw new Error(\\"Instance of Node has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
  export const partialMatch = <R>(n: Node, f: Partial<{
    Function: (n: Function) => R
    Declaration: (n: Declaration) => R
    Argument: (n: Argument) => R
    Body: (n: Body) => R
    AssignmentStatement: (n: AssignmentStatement) => R
    DeclarationStatement: (n: DeclarationStatement) => R
  }>, orElse: R) => {
      if (f.Function) return f.Function;
      if (f.Declaration) return f.Declaration;
      if (f.Argument) return f.Argument;
      if (f.Body) return f.Body;
      if (f.AssignmentStatement) return f.AssignmentStatement;
      if (f.DeclarationStatement) return f.DeclarationStatement;
      return orElse;
    }
}"
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using purify 1`] = `
Object {
  "bases": Map {},
  "leaves": Map {
    "Function" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "args" => Object {
          "struct": "array",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Argument",
            ],
          },
        },
        "body" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Body",
            ],
          },
        },
      },
      "name": "Function",
      "rootUnion": "Node",
      "tag": "function",
      "type": "leaf",
    },
    "Declaration" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "init" => Object {
          "struct": "optional",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "number",
            ],
          },
        },
      },
      "name": "Declaration",
      "rootUnion": "Node",
      "tag": "declaration",
      "type": "leaf",
    },
    "Argument" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "type" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
      },
      "name": "Argument",
      "rootUnion": "Node",
      "tag": "argument",
      "type": "leaf",
    },
    "Body" => Object {
      "extends": Array [],
      "fields": Map {
        "statement" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Statement",
            ],
          },
        },
      },
      "name": "Body",
      "rootUnion": "Node",
      "tag": "body",
      "type": "leaf",
    },
    "AssignmentStatement" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
        "init" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "number",
            ],
          },
        },
      },
      "name": "AssignmentStatement",
      "rootUnion": "Node",
      "tag": "assignmentstatement",
      "type": "leaf",
    },
    "DeclarationStatement" => Object {
      "extends": Array [],
      "fields": Map {
        "name" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "string",
            ],
          },
        },
      },
      "name": "DeclarationStatement",
      "rootUnion": "Node",
      "tag": "declarationstatement",
      "type": "leaf",
    },
  },
  "names": Set {
    "Node",
    "Function",
    "Declaration",
    "Argument",
    "Body",
    "Statement",
    "AssignmentStatement",
    "DeclarationStatement",
  },
  "options": Object {
    "maps": "json",
    "optional": "purify",
    "tagName": "tag",
  },
  "unions": Map {
    "Statement" => Object {
      "name": "Statement",
      "subtypes": Array [
        "AssignmentStatement",
        "DeclarationStatement",
      ],
      "type": "union",
    },
    "Node" => Object {
      "name": "Node",
      "subtypes": Array [
        "Function",
        "Declaration",
        "Argument",
        "Body",
        "Statement",
      ],
      "type": "union",
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for kitchen.yaml using purify 2`] = `
"// DO NOT EDIT
// This file was automatically generated


export interface Function  {
    tag: \\"function\\";
    name: string;
    args: Argument[];
    body: Body;
}
export class Function {
    static is = (x: Node): x is Function => { return x.tag===\\"function\\" }
    static children = (x: Function) => { return [x.body, ...x.args] as const }
    static tag = \\"function\\"
}
export interface Declaration  {
    tag: \\"declaration\\";
    name: string;
    type: string;
    init: Maybe<number>;
}
export class Declaration {
    static is = (x: Node): x is Declaration => { return x.tag===\\"declaration\\" }
    static children = (x: Declaration) => { return [] as const }
    static tag = \\"declaration\\"
}
export interface Argument  {
    tag: \\"argument\\";
    name: string;
    type: string;
}
export class Argument {
    static is = (x: Node): x is Argument => { return x.tag===\\"argument\\" }
    static children = (x: Argument) => { return [] as const }
    static tag = \\"argument\\"
}
export interface Body  {
    tag: \\"body\\";
    statement: Statement;
}
export class Body {
    static is = (x: Node): x is Body => { return x.tag===\\"body\\" }
    static children = (x: Body) => { return [x.statement] as const }
    static tag = \\"body\\"
}
export interface AssignmentStatement  {
    tag: \\"assignmentstatement\\";
    name: string;
    init: number;
}
export class AssignmentStatement {
    static is = (x: Node): x is AssignmentStatement => { return x.tag===\\"assignmentstatement\\" }
    static children = (x: AssignmentStatement) => { return [] as const }
    static tag = \\"assignmentstatement\\"
}
export interface DeclarationStatement  {
    tag: \\"declarationstatement\\";
    name: string;
}
export class DeclarationStatement {
    static is = (x: Node): x is DeclarationStatement => { return x.tag===\\"declarationstatement\\" }
    static children = (x: DeclarationStatement) => { return [] as const }
    static tag = \\"declarationstatement\\"
}
export type Statement = AssignmentStatement | DeclarationStatement;
namespace Statement {
  export const match = <R>(n: Statement, f: {
    AssignmentStatement: (n: AssignmentStatement) => R
    DeclarationStatement: (n: DeclarationStatement) => R
  }) => {
    switch(n.tag) {
      case \\"assignmentstatement\\": return f.AssignmentStatement(n)
      case \\"declarationstatement\\": return f.DeclarationStatement(n)
      default: { const x: never = n; throw new Error(\\"Instance of Statement has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
  export const partialMatch = <R>(n: Statement, f: Partial<{
    AssignmentStatement: (n: AssignmentStatement) => R
    DeclarationStatement: (n: DeclarationStatement) => R
  }>, orElse: R) => {
      if (f.AssignmentStatement) return f.AssignmentStatement;
      if (f.DeclarationStatement) return f.DeclarationStatement;
      return orElse;
    }
}
export type Node = Function | Declaration | Argument | Body | Statement;
namespace Node {
  export const match = <R>(n: Node, f: {
    Function: (n: Function) => R
    Declaration: (n: Declaration) => R
    Argument: (n: Argument) => R
    Body: (n: Body) => R
    AssignmentStatement: (n: AssignmentStatement) => R
    DeclarationStatement: (n: DeclarationStatement) => R
  }) => {
    switch(n.tag) {
      case \\"function\\": return f.Function(n)
      case \\"declaration\\": return f.Declaration(n)
      case \\"argument\\": return f.Argument(n)
      case \\"body\\": return f.Body(n)
      case \\"assignmentstatement\\": return f.AssignmentStatement(n)
      case \\"declarationstatement\\": return f.DeclarationStatement(n)
      default: { const x: never = n; throw new Error(\\"Instance of Node has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
  export const partialMatch = <R>(n: Node, f: Partial<{
    Function: (n: Function) => R
    Declaration: (n: Declaration) => R
    Argument: (n: Argument) => R
    Body: (n: Body) => R
    AssignmentStatement: (n: AssignmentStatement) => R
    DeclarationStatement: (n: DeclarationStatement) => R
  }>, orElse: R) => {
      if (f.Function) return f.Function;
      if (f.Declaration) return f.Declaration;
      if (f.Argument) return f.Argument;
      if (f.Body) return f.Body;
      if (f.AssignmentStatement) return f.AssignmentStatement;
      if (f.DeclarationStatement) return f.DeclarationStatement;
      return orElse;
    }
}"
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using json 1`] = `
Object {
  "bases": Map {},
  "leaves": Map {
    "Fork" => Object {
      "extends": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Tree",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Tree",
            ],
          },
        },
      },
      "name": "Fork",
      "rootUnion": "Tree",
      "tag": "fork",
      "type": "leaf",
    },
    "Leaf" => Object {
      "extends": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "number",
            ],
          },
        },
      },
      "name": "Leaf",
      "rootUnion": "Tree",
      "tag": "leaf",
      "type": "leaf",
    },
  },
  "names": Set {
    "Tree",
    "Fork",
    "Leaf",
  },
  "options": Object {
    "maps": "json",
    "optional": "json",
    "tagName": "tag",
  },
  "unions": Map {
    "Tree" => Object {
      "name": "Tree",
      "subtypes": Array [
        "Fork",
        "Leaf",
      ],
      "type": "union",
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using json 2`] = `
"// DO NOT EDIT
// This file was automatically generated


export interface Fork  {
    tag: \\"fork\\";
    left: Tree;
    right: Tree;
}
export class Fork {
    static is = (x: Tree): x is Fork => { return x.tag===\\"fork\\" }
    static children = (x: Fork) => { return [x.left, x.right] as const }
    static tag = \\"fork\\"
}
export interface Leaf  {
    tag: \\"leaf\\";
    value: number;
}
export class Leaf {
    static is = (x: Tree): x is Leaf => { return x.tag===\\"leaf\\" }
    static children = (x: Leaf) => { return [] as const }
    static tag = \\"leaf\\"
}
export type Tree = Fork | Leaf;
namespace Tree {
  export const match = <R>(n: Tree, f: {
    Fork: (n: Fork) => R
    Leaf: (n: Leaf) => R
  }) => {
    switch(n.tag) {
      case \\"fork\\": return f.Fork(n)
      case \\"leaf\\": return f.Leaf(n)
      default: { const x: never = n; throw new Error(\\"Instance of Tree has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
  export const partialMatch = <R>(n: Tree, f: Partial<{
    Fork: (n: Fork) => R
    Leaf: (n: Leaf) => R
  }>, orElse: R) => {
      if (f.Fork) return f.Fork;
      if (f.Leaf) return f.Leaf;
      return orElse;
    }
}"
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using purify 1`] = `
Object {
  "bases": Map {},
  "leaves": Map {
    "Fork" => Object {
      "extends": Array [],
      "fields": Map {
        "left" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Tree",
            ],
          },
        },
        "right" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "node",
            "types": Array [
              "Tree",
            ],
          },
        },
      },
      "name": "Fork",
      "rootUnion": "Tree",
      "tag": "fork",
      "type": "leaf",
    },
    "Leaf" => Object {
      "extends": Array [],
      "fields": Map {
        "value" => Object {
          "struct": "scalar",
          "type": Object {
            "kind": "builtin",
            "types": Array [
              "number",
            ],
          },
        },
      },
      "name": "Leaf",
      "rootUnion": "Tree",
      "tag": "leaf",
      "type": "leaf",
    },
  },
  "names": Set {
    "Tree",
    "Fork",
    "Leaf",
  },
  "options": Object {
    "maps": "json",
    "optional": "purify",
    "tagName": "tag",
  },
  "unions": Map {
    "Tree" => Object {
      "name": "Tree",
      "subtypes": Array [
        "Fork",
        "Leaf",
      ],
      "type": "union",
    },
  },
}
`;

exports[`Test sample AST specifications should generate proper output for repmin.yaml using purify 2`] = `
"// DO NOT EDIT
// This file was automatically generated


export interface Fork  {
    tag: \\"fork\\";
    left: Tree;
    right: Tree;
}
export class Fork {
    static is = (x: Tree): x is Fork => { return x.tag===\\"fork\\" }
    static children = (x: Fork) => { return [x.left, x.right] as const }
    static tag = \\"fork\\"
}
export interface Leaf  {
    tag: \\"leaf\\";
    value: number;
}
export class Leaf {
    static is = (x: Tree): x is Leaf => { return x.tag===\\"leaf\\" }
    static children = (x: Leaf) => { return [] as const }
    static tag = \\"leaf\\"
}
export type Tree = Fork | Leaf;
namespace Tree {
  export const match = <R>(n: Tree, f: {
    Fork: (n: Fork) => R
    Leaf: (n: Leaf) => R
  }) => {
    switch(n.tag) {
      case \\"fork\\": return f.Fork(n)
      case \\"leaf\\": return f.Leaf(n)
      default: { const x: never = n; throw new Error(\\"Instance of Tree has unexpected value for tag: \\"+(n as any).tag)}
    }
  }
  export const partialMatch = <R>(n: Tree, f: Partial<{
    Fork: (n: Fork) => R
    Leaf: (n: Leaf) => R
  }>, orElse: R) => {
      if (f.Fork) return f.Fork;
      if (f.Leaf) return f.Leaf;
      return orElse;
    }
}"
`;
