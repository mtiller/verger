/**
 * DO NOT EDIT - This file was generated by verger.  If you want to change something
 * edit the upstream AST specification and regenerate this file
 **/

import { Field } from "../specification/nodes";
/**
 * This code implements the types and functions associated with
 * the leaf type IRRoot.
 **/
export interface IRRoot {
  kind: "irroot";
  nodes: Map<string, IRNode>;
}
export class IRRoot {
  /**
   * A predicate function that take an instance of `any` and determines if it is an instance of IRRoot
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is IRRoot => {
    if (x === null || x === undefined) return false;
    if (typeof x !== "object") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes("nodes")) return false;
    if (!keys.includes("kind")) return false;
    return x.kind === "irroot";
  };
  /**
   * A predicate function that take an instance of type IRRoot and determines if it is an instance of IRRoot
   **/
  static is = (x: IRRoot): x is IRRoot => {
    return x.kind === "irroot";
  };
  /**
   * Given an instance of IRRoot, determine all children that are instances of IRRoot
   **/
  static children = (x: IRRoot) => {
    return [...Object.entries(x.nodes).map((x) => x[1] as IRNode)] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of IRRoot
   **/
  static tag = "irroot";
}
/**
 * This function can be invoked to create a new instance of IRRoot
 **/
export function irRoot(nodes: Map<string, IRNode>): IRRoot {
  return { kind: "irroot", nodes };
}

/**
 * This code implements the types and functions associated with
 * the leaf type LeafNode.
 **/
export interface LeafNode {
  kind: "leafnode";
  bases: string[];
  fields: Map<string, Field>;
}
export class LeafNode {
  /**
   * A predicate function that take an instance of `any` and determines if it is an instance of LeafNode
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is LeafNode => {
    if (x === null || x === undefined) return false;
    if (typeof x !== "object") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 3) return false;
    if (!keys.includes("bases")) return false;
    if (!keys.includes("fields")) return false;
    if (!keys.includes("kind")) return false;
    return x.kind === "leafnode";
  };
  /**
   * A predicate function that take an instance of type IRNode and determines if it is an instance of LeafNode
   **/
  static is = (x: IRNode): x is LeafNode => {
    return x.kind === "leafnode";
  };
  /**
   * Given an instance of LeafNode, determine all children that are instances of IRNode
   **/
  static children = (x: LeafNode) => {
    return [...Object.entries(x.fields).map((x) => x[1] as Field)] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of LeafNode
   **/
  static tag = "leafnode";
}
/**
 * This function can be invoked to create a new instance of LeafNode
 **/
export function leafNode(
  bases: string[],
  fields: Map<string, Field>
): LeafNode {
  return { kind: "leafnode", bases, fields };
}

/**
 * This code implements the types and functions associated with
 * the leaf type BaseNode.
 **/
export interface BaseNode {
  kind: "basenode";
  fields: Map<string, Field>;
}
export class BaseNode {
  /**
   * A predicate function that take an instance of `any` and determines if it is an instance of BaseNode
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is BaseNode => {
    if (x === null || x === undefined) return false;
    if (typeof x !== "object") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes("fields")) return false;
    if (!keys.includes("kind")) return false;
    return x.kind === "basenode";
  };
  /**
   * A predicate function that take an instance of type IRNode and determines if it is an instance of BaseNode
   **/
  static is = (x: IRNode): x is BaseNode => {
    return x.kind === "basenode";
  };
  /**
   * Given an instance of BaseNode, determine all children that are instances of IRNode
   **/
  static children = (x: BaseNode) => {
    return [...Object.entries(x.fields).map((x) => x[1] as Field)] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of BaseNode
   **/
  static tag = "basenode";
}
/**
 * This function can be invoked to create a new instance of BaseNode
 **/
export function baseNode(fields: Map<string, Field>): BaseNode {
  return { kind: "basenode", fields };
}

/**
 * This code implements the types and functions associated with
 * the leaf type UnionNode.
 **/
export interface UnionNode {
  kind: "unionnode";
  members: string[];
}
export class UnionNode {
  /**
   * A predicate function that take an instance of `any` and determines if it is an instance of UnionNode
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is UnionNode => {
    if (x === null || x === undefined) return false;
    if (typeof x !== "object") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 2) return false;
    if (!keys.includes("members")) return false;
    if (!keys.includes("kind")) return false;
    return x.kind === "unionnode";
  };
  /**
   * A predicate function that take an instance of type IRNode and determines if it is an instance of UnionNode
   **/
  static is = (x: IRNode): x is UnionNode => {
    return x.kind === "unionnode";
  };
  /**
   * Given an instance of UnionNode, determine all children that are instances of IRNode
   **/
  static children = (x: UnionNode) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of UnionNode
   **/
  static tag = "unionnode";
}
/**
 * This function can be invoked to create a new instance of UnionNode
 **/
export function unionNode(members: string[]): UnionNode {
  return { kind: "unionnode", members };
}

/**
 * This code implements the types and functions associated with
 * the leaf type ExternalNode.
 **/
export interface ExternalNode {
  kind: "externalnode";
  from: string;
  symbol: string;
}
export class ExternalNode {
  /**
   * A predicate function that take an instance of `any` and determines if it is an instance of ExternalNode
   **/
  static anyIs = (x: any, allowExtra: boolean = false): x is ExternalNode => {
    if (x === null || x === undefined) return false;
    if (typeof x !== "object") return false;
    const keys = Object.keys(x);
    if (!allowExtra && keys.length !== 3) return false;
    if (!keys.includes("from")) return false;
    if (!keys.includes("symbol")) return false;
    if (!keys.includes("kind")) return false;
    return x.kind === "externalnode";
  };
  /**
   * A predicate function that take an instance of type IRNode and determines if it is an instance of ExternalNode
   **/
  static is = (x: IRNode): x is ExternalNode => {
    return x.kind === "externalnode";
  };
  /**
   * Given an instance of ExternalNode, determine all children that are instances of IRNode
   **/
  static children = (x: ExternalNode) => {
    return [] as const;
  };
  /**
   * Although generally not necessary, this tag can be used to identify instances of ExternalNode
   **/
  static tag = "externalnode";
}
/**
 * This function can be invoked to create a new instance of ExternalNode
 **/
export function externalNode(from: string, symbol: string): ExternalNode {
  return { kind: "externalnode", from, symbol };
}

/**
 * This code implements the types and functions associated with
 * the union type IRNode.
 **/
export type IRNode = LeafNode | BaseNode | UnionNode | ExternalNode;
export namespace IRNode {
  /**
   * Given an instance of `any` determine it is an instance of any of the leaf types of IRNode
   **/
  export const anyIs = (n: any): n is IRNode => {
    if (LeafNode.anyIs(n)) return true;
    if (BaseNode.anyIs(n)) return true;
    if (UnionNode.anyIs(n)) return true;
    if (ExternalNode.anyIs(n)) return true;
    return false;
  };
  /**
   * Given an instance of IRNode, return a list of all children
   **/
  export const children = (n: IRNode): readonly IRNode[] =>
    map(n, {
      LeafNode: (c): readonly IRNode[] =>
        LeafNode.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      BaseNode: (c): readonly IRNode[] =>
        BaseNode.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      UnionNode: (c): readonly IRNode[] =>
        UnionNode.children(c)
          .map((x) => x as any)
          .filter(anyIs),
      ExternalNode: (c): readonly IRNode[] =>
        ExternalNode.children(c)
          .map((x) => x as any)
          .filter(anyIs),
    });
  /**
   * Given an instance of type IRNode, map that value depending on the
   * specific underlying node type
   **/
  export const map = <R>(
    n: IRNode,
    f: {
      LeafNode: (n: LeafNode) => R;
      BaseNode: (n: BaseNode) => R;
      UnionNode: (n: UnionNode) => R;
      ExternalNode: (n: ExternalNode) => R;
    }
  ) => {
    switch (n.kind) {
      case "leafnode":
        return f.LeafNode(n);
      case "basenode":
        return f.BaseNode(n);
      case "unionnode":
        return f.UnionNode(n);
      case "externalnode":
        return f.ExternalNode(n);
      default: {
        const x: never = n;
        throw new Error(
          "Instance of IRNode has unexpected value for kind: " + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type IRNode, map that value for certain subtypes
   * and for all others, simply return the `orElse` argument
   **/
  export const partialMap = <R>(
    n: IRNode,
    f: Partial<{
      LeafNode: (n: LeafNode) => R;
      BaseNode: (n: BaseNode) => R;
      UnionNode: (n: UnionNode) => R;
      ExternalNode: (n: ExternalNode) => R;
    }>,
    orElse: R
  ) => {
    if (n.kind === "leafnode" && f.LeafNode) return f.LeafNode(n);
    if (n.kind === "basenode" && f.BaseNode) return f.BaseNode(n);
    if (n.kind === "unionnode" && f.UnionNode) return f.UnionNode(n);
    if (n.kind === "externalnode" && f.ExternalNode) return f.ExternalNode(n);
    return orElse;
  };
  /**
   * Given an instance of type IRNode, take action depending on the
   * specific underlying node type
   **/
  export const match = (
    n: IRNode,
    f: {
      LeafNode: (n: LeafNode) => void;
      BaseNode: (n: BaseNode) => void;
      UnionNode: (n: UnionNode) => void;
      ExternalNode: (n: ExternalNode) => void;
    }
  ): void => {
    switch (n.kind) {
      case "leafnode":
        return f.LeafNode(n);
      case "basenode":
        return f.BaseNode(n);
      case "unionnode":
        return f.UnionNode(n);
      case "externalnode":
        return f.ExternalNode(n);
      default: {
        const x: never = n;
        throw new Error(
          "Instance of IRNode has unexpected value for kind: " + (n as any).tag
        );
      }
    }
  };
  /**
   * Given an instance of type IRNode, take action for certain subtypes
   * and for all others, simply return the `orElse` argument
   **/
  export const partialMatch = (
    n: IRNode,
    f: Partial<{
      LeafNode: (n: LeafNode) => void;
      BaseNode: (n: BaseNode) => void;
      UnionNode: (n: UnionNode) => void;
      ExternalNode: (n: ExternalNode) => void;
    }>,
    orElse?: (n: IRNode) => void
  ) => {
    if (n.kind === "leafnode" && f.LeafNode) return f.LeafNode(n);
    if (n.kind === "basenode" && f.BaseNode) return f.BaseNode(n);
    if (n.kind === "unionnode" && f.UnionNode) return f.UnionNode(n);
    if (n.kind === "externalnode" && f.ExternalNode) return f.ExternalNode(n);
    if (orElse) return orElse(n);
  };
}
